<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>AssureVision</title>

    <!-- jQuery (required by Semantic UI JavaScript) -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

    <!-- ✅ Fomantic UI CSS and JS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fomantic-ui/2.9.4/semantic.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fomantic-ui/2.9.4/semantic.min.js"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <!-- Driver.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/driver.js@latest/dist/driver.js.iife.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/driver.js@latest/dist/driver.css" />

    <style>
        .extra.content canvas {
            width: 100% !important;

        }

        /* Styling for Specific Date Calendar */
        #specificDateCalendar {
            max-width: 250px;
            margin-top: 1rem;
            /* Ensure spacing from other elements */
        }



        /* Accordion Scroll Customization */
        .accordion .content {
            display: flex;
            flex: 0 0 auto;
            max-width: 100%;
            padding: 10px 0;
            gap: 10px;
        }

        .accordion .content::-webkit-scrollbar {
            height: 20px;
        }

        .accordion .content::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 4px;
        }

        /* Body padding */
        body {
            padding: 1em;
            background-color: #f1f1f1;

        }

        /* Styling for the SVG Viewer */
        #svgViewer {
            border: 1px solid #ccc;
            width: 100%;
            height: auto;
            display: block;
        }

        /* SVG Container */
        .svg-container {
            width: 100%;
            height: auto;
            max-height: 500px;
            overflow: auto;
        }

        /* Right Side Toggles - Align and Style */
        .ui.form .field .ui.toggle.checkbox {
            margin-top: 1rem;
        }

        /* Specific date picker input styling */
        #specificDateInput {
            max-width: 200px;
            margin-bottom: 10px;
        }

        /* General Form Spacing Adjustments */
        .ui.form .fields .field {
            margin-bottom: 1.5rem;
        }

        /* Toggle Alignment */
        .ui.toggle.checkbox {
            margin-top: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: flex-start;
        }

        /* Responsive Design Enhancements */
        @media (max-width: 768px) {
            .ui.stackable.grid {
                display: block;
                /* Stack content vertically on smaller screens */
            }

            .ten.wide.column {
                width: 100%;
            }

            .six.wide.column {
                width: 100%;
                margin-top: 1.5rem;
            }

            /* Adjust button margins */
            .ui.buttons>.button {
                margin-bottom: 1rem;
            }
        }

        .ui.card {
            transition: opacity 0.3s ease-in;
        }

        .ui.card[data-loaded="true"] {
            opacity: 1;
        }

        .ui.cardrtx {
            height: 250px;
            margin: 10px;
            box-sizing: border-box;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding-top: 40px;
        }

        select,
        button {
            margin-top: 10px;
            display: block;
        }

        #qrcode-wrapper {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 300px;
        }

        #qrcode {
            text-align: center;
        }

        #bottom-title {
            text-align: center;
            font-size: 18px;
            margin-top: 20px;
            padding-bottom: 70px;
        }

        @media print {

            /* Hide everything except container */
            body * {
                visibility: hidden;
            }


            .container,
            .container * {
                visibility: visible;
            }

            body,
            html {
                margin: 0;
                padding: 0;
                height: 100vh;
                width: 100vw;
                overflow: hidden;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .container {
                margin: 0;
                padding: 0;
                height: auto;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                page-break-after: avoid;
                page-break-before: avoid;
                page-break-inside: avoid;
            }



            #qrcode-wrapper {
                margin: 0;
                padding: 0;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            #qrcode {
                margin: 0;
            }

            #bottom-title {
                margin-top: 8px;
                /* tight spacing */
                font-size: 18px;
                text-align: center;
            }
        }

        #summaryChart {
            width: 50%;
        }
    </style>

</head>

<body>

    <!-- Global Loader Overlay -->
    <div id="globalLoader" class="ui active  dimmer" style="display: none;   position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;">
        <div class="ui text loader fast teal ">
            Loading...

            <div class="ui teal progress" data-percent="0" id="progressBar">
                <div class="bar"></div>
            </div>
        </div>

    </div>
    <!-- Top Fixed Menu -->
    <div class="ui top fixed menu stackable fluid five item" style="z-index: 1000; height: 4rem;">
        <!-- Logo and Title -->
        <div class="item ">
            <h3 class="ui header ">
                <span style="display: inline-flex; align-items: center;">
                    <i class="shield alternate icon teal" style="margin-right: 8px;"></i>
                    AssureVision
                </span>
                <div class="sub header">Engineered by Keith Carter</div>
            </h3>

        </div>

        <!-- Action Buttons -->
        <div class="item" id="action-btns">
            <div class="ui ">
                <button class="ui  button circular teal" id="folderPicker">

                    <span id="dirHandle"><i class="folder open icon"></i>Folder</span>
                </button>
                <button class="ui  button circular icon teal basic" id="reloadBtn">
                    <i class="redo icon"></i>

                </button>
            </div>
        </div>

        <div class="item">
            <div class="ui search  fluid " id="searchQry">
                <input class="prompt" type="text" placeholder="Search...">
                <div class="results"></div>
            </div>
        </div>

        <!-- Date Filter Dropdown -->
        <div class="item">
            <div style="margin-left:1%;">
                <div class="ui three column grid">
                    <div class="row">
                        <div class="column">
                            <div class="ui calendar" id="rangestart">
                                <div class="ui button circular tiny">Start Date</div>
                            </div>
                        </div>
                        <div class="column">
                            <div class="ui calendar" id="rangeend">
                                <div class="ui button circular tiny">End Date</div>
                            </div>
                        </div>
                        <div class="column">
                            <div id="clearDates">
                                <div class="ui button circular tiny">Clear Date</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="item ">
            <button class="ui orange circular button" id="startTourBtn">
                <i class="compass alternate icon " style="margin-right: 8px;"></i>
                Start Tour
            </button>

        </div>
    </div>

    <div class="ui top fixed menu stackable fluid three " style="z-index: 999; height: 4rem; top:4em;  ">
        <div class=" header item ">Filter & Sort</div>
        <div class="item  ">
            <div class="ui form " style="margin-top: 1em; ">
                <div class=" fields inline ">
                    <div class="field six wide labeled ">
                        <div class="ui label">Start Time</div>
                        <input type="time" id="startTimeInput" />
                    </div>
                    <div class="field six wide labeled">
                        <div class="ui label">End Time</div>
                        <input type="time" id="endTimeInput" />
                    </div>
                    <div class="field four wide">
                        <div class="ui buttons circular ">
                            <button class="ui blue small basic  button " id="applyFilterBtn">Apply</button>
                            <button class="ui basic small  button " id="applyFilterClearBtn">
                                Clear
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="item">
            <div class="ui dropdown selection groupKey">
                <i class="dropdown icon"></i>
                <div class="default text">Select Part Number</div>
                <div class="menu" id="groupKey">
                </div>
            </div>
        </div>

        <!-- Filter Dropdown -->
        <div class="item">
            <div class="ui selection dropdown" id="filterDropdown">
                <input type="hidden" name="filter" />
                <i class="dropdown icon"></i>
                <div class="default text">Select Filter</div>
                <div class="menu">
                    <div class="item" data-value="">All</div>
                    <!-- Add more filter items dynamically -->
                </div>
            </div>
        </div>

        <div class="item  ">
            <div class="ui icon button black circular" id="sortByDateBtn" title="Toggle sort direction">
                <i class="sort amount down icon"></i>
            </div>
        </div>
    </div>

    <!-- Sidebar -->
    <div class="ui left vertical  sidebar menu stackable visible  inverted" style="top: 8em; ">
        <div class="item">
            <div class="ui mini progress teal " id="toast-progress" data-percent="0">
                <div class="bar"></div>
            </div>
        </div>
        <div class="item">
            <div class="header">Main</div>
            <a class="item active" data-tab="dashboard-page">
                <div id="iconLabelDash"></div> <i class="dashboard grey icon" id="iconDashboard"></i>Dashboard
            </a>
            <a class="item" data-tab="chart-page">Charts <i class="chart bar line grey icon" id="iconCharts">
                </i> </a>
            <a class="item" data-tab="system-page">System Health <i class="heartbeat  grey  icon"
                    id="iconSystemHealth"></i></a>
            <a class="item" data-tab="image-page" id="image-deck">Image Deck <i class="images outline grey   icon"
                    id="iconImaging"></i></a>
            <a class="item" data-tab="qr-page">QR<i class="barcode icon grey "></i></a>
        </div>

        <div class="item">
            <div class="header">Device Folder</div>
            <div class="ui selection dropdown" id="deviceType">
                <input type="hidden" name="deviceType">
                <i class="dropdown icon"></i>
                <div class="default text">Select Device</div>
                <div class="menu">
                    <div class="item selected" data-value="FS">FS</div>
                    <div class="item" data-value="OS">OS</div>
                    <div class="item" data-value="EM">EM</div>
                </div>
            </div>
        </div>


        <div class="item">
            <div class="header">Settings</div>
            <a class="item" data-tab="setting-page"> <i class="sync grey icon"></i> Auto Sync</a>
            <a class="item" data-tab="setting-grid"> <i class="ruler combined grey icon"></i> Image Layout</a>

        </div>
    </div>

    <!-- Main content container with left margin -->
    <div class="pusher " style=" margin-top: 7em; padding: 1em;">

        <!-- Tab 1: Dashboard Stats -->
        <div class="ui grid active tab" data-tab="dashboard-page">
            <!-- Tab 1: Dash View -->
            <div class="row">
                <div class="ui  column twelve wide">

                    <!-- Tab Menu -->
                    <div class="ui top  tabular menu stackable secondary pointing teal  ">
                        <a class="item active" data-tab="dashboard">Dasshoboard</a>
                        <a class="item" data-tab="predicted">Predicted Class</a>
                        <a class="item" data-tab="trendVisualizerCard">Trend Deck </a>

                    </div>

                    <div class="ui bottom  tab " data-tab="trendVisualizerCard">
                        <div class=" ui grid ">
                            <div class="row">
                                <div class="column twelve wide">
                                    <div id="trend-container-card"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="ui bottom  tab " data-tab="predicted">
                        <div class=" ui grid ">
                            <div class="row">
                                <div class="column twelve wide">
                                    <div class="ui" id="stats-container-main"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="ui bottom  tab   active" data-tab="dashboard">
                        <div class=" ui grid ">
                            <div class="row">

                                <div class="column sixteen wide">
                                    <div id="stats-container-main-stats"></div>

                                </div>
                            </div>
                            <div class="row">
                                <div class="column sixteen wide">
                                    <h4 class="ui header attached top">Cumulative Reads</h4>
                                    <div class="ui segment attached bottom" id="cumulativeCount">
                                        <canvas style="height: 250px; width: auto;" id="cumulativeCountChart"></canvas>
                                    </div>
                                </div>

                            </div>

                            <div class="row">

                                <div class="column sixteen wide">
                                    <div class="ui " id="groupKey-table-filter"></div>
                                    <div id="summary-container"></div>
                                    <button class="ui button primary" id="loadMoreBtn">Load More</button>

                                </div>

                            </div>

                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab 2: Charts  -->
        <div class="ui grid tab " data-tab="chart-page">
            <!-- Dash View -->
            <div class="row">
                <div class="ui   column twelve wide">
                    <!-- Tab Menu -->
                    <div class="ui top  tabular menu stackable secondary pointing teal  ">
                        <a class="item" data-tab="summary">Category Summary</a>
                        <a class="item active" data-tab="timeline">Timeline</a>
                        <a class="item" data-tab="trendVisualizer ">Trend Visualizer</a>
                    </div>

                    <!-- Tab 2: Category Summary -->
                    <div class="ui bottom  tab " data-tab="summary">
                        <div class="ui grid ">
                            <div class="row">
                                <div class="column twelve wide">
                                    <div class=" ui header attached top" id="summary-header">Grouped Comparison of Field
                                        Values</div>
                                    <div class="ui segment attached bottom">
                                        <canvas id="summaryChart"></canvas>
                                    </div>
                                </div>
                                <div class="column four wide">
                                    <div class="ui segment">
                                        <h4 class="ui dividing header">View Options</h4>

                                        <div class="ui toggle checkbox">
                                            <input type="checkbox" id="stackToggle">
                                            <label>Stacked View</label>
                                        </div>
                                    </div>
                                </div>

                            </div>
                        </div>
                    </div>

                    <!-- Tab 3: Timeline -->
                    <div class="ui bottom active tab " data-tab="timeline">
                        <div class="ui grid">
                            <div class="row">

                                <div class="twelve wide column">
                                    <div class="ui header attached top">Filtered Timeline (Time on X-axis)</div>
                                    <div class="ui segment attached bottom">
                                        <canvas id="timelineChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tab 4: Trend Visualizer -->
                    <div class="ui bottom  tab " data-tab="trendVisualizer ">
                        <div class=" ui grid ">
                            <div class="row">
                                <div class="column twelve wide">
                                    <div id="trend-container"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- Tab 3: System  -->
        <div class="ui grid tab " data-tab="system-page">
            <!-- Dash View -->
            <div class="row">
                <div class="ui column sixteen wide">
                    <!-- Tab Menu -->
                    <div class="ui top  tabular menu stackable secondary pointing teal  ">
                        <a class="item active" data-tab="health-chart">Health Chart</a>
                        <a class="item" data-tab="health-summary">Summary</a>
                    </div>

                    <div class="ui grid tab active " data-tab="health-chart">
                        <div class="row">
                            <div class="column twelve wide">
                                <div class="ui header attached top">Job Count Over Time (Pass vs Fail, by Prefix)</div>
                                <div class="ui segment attached bottom">
                                    <div class="ui" id="system-health-label"></div>
                                    <canvas id="heartbeatChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>


                    <div class="ui grid tab " data-tab="health-summary">
                        <div class="row">
                            <div class="column twelve wide">
                                <div class="ui  ">
                                    <div class="ui" id="stats-container"></div>
                                </div>
                            </div>
                        </div>
                    </div>


                </div>
            </div>
        </div>

        <!-- Tab 4: Images  -->
        <div class="ui grid tab " data-tab="image-page">
            <!-- Dash View -->
            <div class="row">
                <div class="ui  basic column twelve wide" style="display: block; ">
                    <!-- Tab Menu 
                    <div class="ui top  tabular menu stackable secondary pointing teal  ">
                        <a class="item active" data-tab="info-card-deck-view">Info Deck</a>
                        <a class="item" data-tab="imageView">Image Preview</a>
                    </div>-->

                    <!-- Tab 5: Info Deck Stats -->
                    <div class="ui active   segment basic " data-tab="info-card-deck-view">


                        <div id="virtual-container" class="ui grid">
                            <!-- First Row: Segments -->
                            <div class="row">
                                <!-- Segment 1 -->
                                <div class="six wide column">
                                    <div class="ui segment">
                                        <object id="svgViewer" type="image/svg+xml"></object>
                                    </div>
                                </div>
                                <!-- Segment 2 -->
                                <div class="six wide column">
                                    <div class="ui segment" style="height: 50vb; overflow-y: scroll;">
                                        <!-- Card View -->
                                        <div class="ui cards two stackable" id="cardGridContainer">
                                            <!-- Cards dynamically injected here -->
                                            <div id="cardGridSpacerTop"></div>
                                            <div class="" id="cardGridInner"></div>
                                            <div id="cardGridSpacerBottom"></div>
                                        </div>

                                    </div>
                                </div>
                                <!-- Segment 3 -->
                                <div class="four wide column">
                                    <div class="ui segment" style="height: 50vb;">
                                        <h4 class="ui header">Associated Data</h4>
                                        <div style="overflow-x: auto;">
                                            <table class="ui celled compact small table">
                                                <thead>
                                                    <tr>
                                                        <th>Key</th>
                                                        <th>Value</th>
                                                    </tr>
                                                </thead>
                                                <tbody id="dataTable">
                                                    <!-- Dynamic Rows -->
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Second Row: Virtual List -->
                            <div class="row">
                                <div class="sixteen wide column">

                                    <div class="ui segment attached ">
                                        <table class="ui celled table  short  scrolling">
                                            <thead>
                                                <tr>
                                                    <th>Date</th>
                                                    <th>Name</th>
                                                    <th>Good Read</th>
                                                    <th>Read Data String</th>
                                                </tr>
                                            </thead>
                                            <tbody id="paginated-table-body">
                                                <!-- Rows go here -->
                                            </tbody>
                                        </table>

                                    </div>
                                    <div class="ui segment bottom attached right aligned">
                                        <div id="pagination-controls" class="ui pagination menu ">
                                            <!-- Pagination buttons go here -->
                                        </div>
                                    </div>


                                </div>
                            </div>
                        </div>



                        <!-- Tab 6:  Image Preview & Data -->
                        <div class="ui  tab segment basic " data-tab="imageView">

                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab 5: QR  -->
        <div class="ui grid tab " data-tab="qr-page">
            <!-- Dash View -->
            <div class="row">
                <div class="ui  basic column twelve wide" style="display: block; ">

                    <!-- Tab 6:  Qr -->
                    <div class="ui  " data-tab="qrMakerView">
                        <div class="container">
                            <h2>QR Code Generator</h2>

                            <label for="preset-select">Choose a preset:</label>
                            <select id="preset-select">
                                <option value="">-- Select a preset --</option>
                            </select>

                            <button id="generate-btn">Generate QR Code</button>

                            <div id="qrcode-wrapper">
                                <div id="qrcode"></div>
                            </div>

                            <div id="bottom-title"></div>
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- Tab 6: Setting  -->

        <div class="ui grid tab " data-tab="setting-page">
            <!-- Dash View -->
            <div class="ui header">Settings</div>
            <div class="row">
                <div class="ui  basic column twelve wide" style="display: block; ">
                    <!-- Right-aligned Cog Icon (Optional) -->
                    <div class="ui segment aligned left">
                        <div class="ui toggle checkbox">
                            <input type="checkbox" id="autoReloadToggle" />
                            <label>Auto-Reload</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="ui grid tab " data-tab="setting-grid">
            <!-- Dash View -->
            <div class="ui header">Settings</div>
            <div class="row">
                <div class="ui  basic column twelve wide" style="display: block; ">
                    <!-- Right-aligned Cog Icon (Optional) -->
                    <div class="ui segment aligned left">
                        <div class="ui toggle checkbox card-grid">
                            <input type="checkbox" id="cardGridToggle" />
                            <label id="gridLabel"> Show List</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    </div>
    <!-- Fullscreen Overlay Modal -->
    <div class="ui overlay fullscreen modal">
        <i class="close icon"></i>
        <div class="header modal-header">
            Fullscreen Image
        </div>
        <div class="content modal-content">
            <!-- Single Image View -->
            <div id="imageView" class="ui stackable grid">
                <div class="ten wide column">
                    <div class="ui segment">
                        <h4 class="ui header">Preview</h4>
                        <object id="svgViewerOld" type="image/svg+xml"></object>
                        <button class="ui green button" id="saveBtn" style="margin-top: 1rem;">
                            <i class="save icon"></i>
                            Train
                        </button>

                    </div>
                </div>

                <div class="six wide column">

                    <div class="ui segment">
                        <h4 class="ui header">Associated Data</h4>
                        <div style="overflow-x: auto;">
                            <table class="ui celled compact small table">
                                <thead>
                                    <tr>
                                        <th>Key</th>
                                        <th>Value</th>
                                    </tr>
                                </thead>
                                <tbody id="dataTable">
                                    <!-- Dynamic Rows -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class=" ui segment">
                        <h4 class="ui header">Playback Controls</h4>

                        <div id="slideshowControls" class="ui buttons small circular">
                            <button class="ui button icon" id="prevBtn"><i class="step backward icon"></i></button>
                            <button class="ui teal button icon" id="playBtn"><i class="play icon"></i></button>
                            <button class="ui red button icon" id="pauseBtn"><i class="pause icon"></i></button>
                            <button class="ui button icon" id="nextBtn"><i class="step forward icon"></i></button>


                        </div>
                        <button class="ui compact menu button small circular">
                            <div class=" ui simple dropdown item">
                                Speed
                                <i class="dropdown icon"></i>
                                <div class="menu">
                                    <div class="item" data-speed="1000">1s</div>
                                    <div class="item" data-speed="3000">3s</div>
                                    <div class="item" data-speed="5000">5s</div>
                                </div>
                            </div>
                        </button>
                    </div>
                    <div class="ui segment">
                        <div class="item">
                            <h4 class="ui dividing header">Available Images (Grouped by Prefix)</h4>
                            <div class="ui styled fluid accordion" id="imageList"></div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
        <div class="actions">
            <div class="ui red cancel button">Close</div>
        </div>
    </div>

    <script type="module">

        class TextSaver {
            static storageKey = 'textSaverContent';
            static userId = 'user123'; // Replace with actual logic/session ID
            static endpoint = `/api/notes/${TextSaver.userId}.json`;

            // Initialize: fetch from server, update localStorage & textarea
            static async init() {
                const textarea = document.getElementById('textInput');

                try {
                    const res = await fetch(TextSaver.endpoint);
                    if (!res.ok) throw new Error('Fetch failed');
                    const data = await res.json();
                    localStorage.setItem(TextSaver.storageKey, data.content || '');
                } catch (err) {
                    console.warn("Could not fetch server note, falling back to localStorage", err);
                }

                textarea.value = localStorage.getItem(TextSaver.storageKey) || '';

                textarea.addEventListener('input', () => {
                    localStorage.setItem(TextSaver.storageKey, textarea.value);
                });
            }

            static saveText() {
                const text = localStorage.getItem(TextSaver.storageKey) || '';
                const blob = new Blob([text], { type: 'text/plain' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'note.txt';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            static openText() {
                const text = localStorage.getItem(TextSaver.storageKey) || '';
                const newWindow = window.open();
                newWindow.document.write(`<pre>${TextSaver.escapeHtml(text)}</pre>`);
                newWindow.document.title = "Note View";
            }

            static escapeHtml(str) {
                return str
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }
        }

        class TrendVisualizerCards {
            constructor(containerId, dataArray, animatedCounter, updateSearch) {
                this.statCard = null;
                this.container = document.getElementById(containerId);
                if (!this.container) {
                    throw new Error(`Container with ID "${containerId}" not found.`);
                }
                this.animatedCounter = animatedCounter;
                this.processedData = this.analyzeTrends(dataArray);
                this.sortingOrder = false;
                this.filterValue = null;
                this.isUpdating = false;
                this.updateSearch = updateSearch

                this.render();
                this.init();

            }

            init() {
                try {
                    document.querySelectorAll('.fail-counter').forEach(el => {
                        const target = parseInt(el.getAttribute('data-value'));
                        if (typeof this.animatedCounter === 'function') {
                            this.animatedCounter(el, target);
                        } else {
                            console.warn("animatedCounter is not a function:", this.animatedCounter);
                        }
                    });

                    document.querySelectorAll('.ellipsis.icon').forEach(el => {
                        $('.dropdown.ellipsis').dropdown({
                            onChange: (value) => {
                                this.filterMap(value);
                                if (value.includes('filter')) {
                                    const formattedValue = value.split(' ')[1];
                                    this.updateSearch(formattedValue);
                                }
                            }
                        })
                    });

                    this.statCard = document.querySelectorAll('.stat-card');

                } catch (error) {
                    console.warn(error);
                }
            }
            updatingBool() {
                this.statCard.forEach(el => {
                    el.classList.remove('loading');
                });

            }

            filterMap(value) {
                const sortedData = [...this.processedData].sort((a, b) => {
                    switch (value) {
                        case 'date':
                            return new Date(b.date) - new Date(a.date)

                        case 'color':
                            return b.color.localeCompare(a.color)

                        case 'group key':
                            return a.groupKey.localeCompare(b.groupKey)
                        case 'total fail':
                            return b.totalFail - a.totalFail

                        case 'total pass':
                            return a.totalPass - b.totalPass

                        case 'most seen classification failure':
                            return b.mostSeenClassificationFailure.localeCompare(a.mostSeenClassificationFailure)

                        case 'fail to pass ratio':
                            return b.failToPassRatio - a.failToPassRatio

                        default:
                            return 0;
                    }
                });
                this.processedData = sortedData;
                this.render();
                this.init();
                this.updatingBool();

            }

            analyzeTrends(dataArray) {
                const grouped = {};

                dataArray.forEach(item => {
                    const groupKey = item.groupKey;
                    const date = new Date(item.date).toISOString().split('T')[0];
                    const key = `${groupKey}__${date}`;

                    if (!grouped[key]) {
                        grouped[key] = {
                            groupKey,
                            date,
                            totalFail: 0,
                            totalPass: 0,
                            classificationFailures: {}
                        };
                    }

                    const group = grouped[key];
                    const fail = this.extractLabelValue(item.labels, 'Job.Fail');
                    const pass = this.extractLabelValue(item.labels, 'Job.Pass');

                    group.totalFail += fail;
                    group.totalPass += pass;

                    if (fail > 0) {
                        item.labels.forEach(label => {
                            if (label.startsWith('Classify_') && !label.includes('OK')) {
                                group.classificationFailures[label] = (group.classificationFailures[label] || 0) + 1;
                            }
                        });
                    }
                });

                return Object.values(grouped).map(group => {
                    const mostSeenFailure = Object.entries(group.classificationFailures).sort((a, b) => b[1] - a[1])[0];

                    const fTRatio = group.totalPass > 0 ? +(group.totalFail / group.totalPass).toFixed(2) : '0.00'

                    const color =
                        (fTRatio === '0.00') ? "blue" :
                            (fTRatio < .05) ? "green" :
                                (fTRatio <= .15) ? "orange" : "red"

                    return {
                        color: color,
                        groupKey: group.groupKey,
                        date: group.date,
                        totalFail: group.totalFail,
                        totalPass: group.totalPass,
                        failToPassRatio: group.totalPass > 0 ? (group.totalFail / group.totalPass).toFixed(2) : 0,
                        mostSeenClassificationFailure: mostSeenFailure ? mostSeenFailure[0].split('=')[1] : 'None'
                    };
                });
            }

            extractLabelValue(labels, key) {
                const label = labels.find(l => l.startsWith(`${key}=`));
                return label ? parseInt(label.split('=')[1], 10) : 0;
            }

            render() {
                this.container.innerHTML = '';

                const cardGrid = document.createElement('div');
                cardGrid.className = 'ui stackable cards big  three basic';

                this.processedData.forEach(data => {
                    const card = this.createCard(data);
                    cardGrid.appendChild(card);
                });

                this.container.appendChild(cardGrid);
            }



            createCard(data) {
                const color = data.color;

                const card = document.createElement('div');
                card.className = `ui card fluid stat-card    ${color}`;

                // Header
                const header = document.createElement('div');
                header.className = 'content';
                const [year, month, day] = data.date.split('-').map(Number);
                const dateFormatted = new Date(year, month - 1, day); // correct local date

                const formatted = new Intl.DateTimeFormat('en-US', {
                    year: '2-digit',
                    month: '2-digit',
                    day: '2-digit'
                }).format(dateFormatted);

                header.innerHTML = `
            <div class="header">${data.groupKey}</div>
            <div class="right floated header  ">
                <button class='button circular ui white inverted   mini icon dropdown ellipsis'>  
                    <i class="ellipsis vertical icon" style="visibility: visible;"></i>
                
              
                <div class=" menu">
                   
                            <div class="item">Filter ${data.groupKey}</div> 

                    <div class="item">Date</div>
                    <div class="item">Color</div>
                    <div class="item">Group Key</div>
                    <div class="item">Fail To Pass Ratio</div>
                    <div class="item">Total Fail</div>
                    <div class="item">Total Pass</div>
                    <div class="item">Most Seen Classification Failure</div>

                  
                    </div>
                    </button>
                </div>
            <div class="meta">${formatted}</div>
        `;

                // Stats
                const stats = document.createElement('div');
                stats.className = 'content';
                stats.appendChild(this.createStats(data));

                const extraContent = document.createElement('div');
                extraContent.className = 'extra content';

                const cardLabel = document.createElement('div');
                cardLabel.className = `ui button ${color}  `;
                cardLabel.textContent = ` Top Failure: ${data.mostSeenClassificationFailure}`;

                extraContent.appendChild(cardLabel);

                card.appendChild(header);
                card.appendChild(stats);
                card.appendChild(cardLabel);
                return card;
            }

            createStats(data) {
                const statsWrapper = document.createElement('div');
                statsWrapper.className = 'ui four small statistics ';

                const stats = [
                    { label: 'Fails', value: data.totalFail, color: 'red' },
                    { label: 'Passes', value: data.totalPass, color: 'green' },
                    { label: 'Ratio', value: data.failToPassRatio, color: 'blue' },
                ];

                stats.forEach(stat => {
                    const div = document.createElement('div');
                    div.className = `ui statistic fluid  inverted `;
                    div.innerHTML = `

                <div class="value ${stat.label.includes('Fails') || stat.label.includes('Pass') ? "fail-counter" : null}"  data-value="${stat.value}">${stat.value}</div>
                <div class="label">${stat.label}</div>
            `;
                    statsWrapper.appendChild(div);
                });

                return statsWrapper;
            }
        }

        class TrendVisualizer {
            constructor(containerId, dataArray) {
                this.container = document.getElementById(containerId);
                if (!this.container) {
                    throw new Error(`Container with ID "${containerId}" not found.`);
                }

                this.processedData = this.analyzeTrends(dataArray);

                this.render();
                this.init();
            }

            init() {
                $(document).on('ready', () => { $('table').tablesort() });

            }
            analyzeTrends(dataArray) {
                const grouped = {};

                dataArray.forEach(item => {

                    const groupKey = item.groupKey;
                    const date = new Date(item.date).toISOString().split('T')[0];
                    const key = `${groupKey}__${date}`;

                    if (!grouped[key]) {
                        grouped[key] = {
                            groupKey,
                            date,
                            totalFail: 0,
                            totalPass: 0,
                            classificationFailures: {}
                        };
                    }

                    const group = grouped[key];
                    const fail = this.extractLabelValue(item.labels, 'Job.Fail');
                    const pass = this.extractLabelValue(item.labels, 'Job.Pass');

                    group.totalFail += fail;
                    group.totalPass += pass;

                    if (fail > 0) {
                        item.labels.forEach(label => {
                            if (label.startsWith('Classify_') && !label.includes('OK')) {
                                group.classificationFailures[label] = (group.classificationFailures[label] || 0) + 1;
                            }
                        });
                    }
                });

                return Object.values(grouped).map(group => {
                    const mostSeenFailure = Object.entries(group.classificationFailures).sort((a, b) => b[1] - a[1])[0];
                    return {
                        groupKey: group.groupKey,
                        date: group.date,
                        totalFail: group.totalFail,
                        totalPass: group.totalPass,
                        failToPassRatio: group.totalPass > 0 ? (group.totalFail / group.totalPass).toFixed(2) : 0,
                        mostSeenClassificationFailure: mostSeenFailure ? mostSeenFailure[0].split('=')[1] : 'None'
                    };
                });
            }

            extractLabelValue(labels, key) {
                const label = labels.find(l => l.startsWith(`${key}=`));
                return label ? parseInt(label.split('=')[1], 10) : 0;
            }

            render() {

                // Clear previous content
                this.container.innerHTML = '';

                // Create layout
                const chartCanvas = document.createElement('canvas');
                const table = document.createElement('table');
                table.className = 'ui  table  sortable';

                this.container.appendChild(chartCanvas);
                this.container.appendChild(document.createElement('br'));
                this.container.appendChild(table);

                this.renderChart(chartCanvas);
                this.renderTable(table);

            }

            renderChart(canvas) {
                const labels = this.processedData.map(d => `${d.groupKey} (${d.date})`);
                const fails = this.processedData.map(d => d.totalFail);
                const passes = this.processedData.map(d => d.totalPass);

                new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels,
                        datasets: [
                            {
                                label: 'Fails',
                                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                                data: fails
                            },
                            {
                                label: 'Passes',
                                backgroundColor: 'rgba(75, 192, 192, 0.6)',
                                data: passes
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top'
                            },
                            title: {
                                display: true,
                                text: 'Fail vs Pass Trend'
                            }
                        },
                        scales: {
                            x: {
                                stacked: true
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            renderTable(table) {

                table.innerHTML = `
            <thead>
                <tr >
                    <th >Part Number </th>
                    <th class="sorted ascending ">Date</th>
                    <th>Fails</th>
                    <th>Passes</th>
                    <th>Fail:Pass Ratio</th>
                    <th>Most Seen Failure</th>
                </tr>
            </thead>
            <tbody>
                ${this.processedData.map((d, i) => `
                    <tr>
                        <td>${d.groupKey}</td>
                        <td>${d.date}</td>
                        <td>${d.totalFail}</td>
                        <td>${d.totalPass}</td>
                        <td class="${(d.failToPassRatio === 0) ? "blue" : (d.failToPassRatio < .05) ? "green" : (d.failToPassRatio >= .05 && d.failToPassRatio <= .15) ? "yellow" : "red"}">${d.failToPassRatio}%</td>
                        <td>${d.mostSeenClassificationFailure}</td>
                    </tr>
                `).join('')}
            </tbody>
        `;
            }
        }

        class TimeFilterForm {
            constructor(containerId, instanceId) {
                this.container = document.getElementById(containerId);
                this.instanceId = instanceId || Date.now(); // fallback unique ID
            }

            createForm() {
                const formDiv = document.createElement("div");
                formDiv.className = "ui form";
                formDiv.style.marginTop = "1em";

                const fieldsDiv = document.createElement("div");
                fieldsDiv.className = "fields inline";

                // === Start Time Field ===
                const startFieldDiv = document.createElement("div");
                startFieldDiv.className = "field six wide labeled";

                const startLabel = document.createElement("div");
                startLabel.className = "ui label";
                startLabel.textContent = "Start Time";

                const startInput = document.createElement("input");
                startInput.type = "time";
                startInput.id = `startTimeInput-${this.instanceId}`;

                startFieldDiv.appendChild(startLabel);
                startFieldDiv.appendChild(startInput);

                // === End Time Field ===
                const endFieldDiv = document.createElement("div");
                endFieldDiv.className = "field six wide labeled";

                const endLabel = document.createElement("div");
                endLabel.className = "ui label";
                endLabel.textContent = "End Time";

                const endInput = document.createElement("input");
                endInput.type = "time";
                endInput.id = `endTimeInput-${this.instanceId}`;

                endFieldDiv.appendChild(endLabel);
                endFieldDiv.appendChild(endInput);

                // === Buttons Field ===
                const buttonFieldDiv = document.createElement("div");
                buttonFieldDiv.className = "field four wide";

                const buttonGroupDiv = document.createElement("div");
                buttonGroupDiv.className = "ui buttons circular";

                const applyBtn = document.createElement("button");
                applyBtn.className = "ui blue small basic button";
                applyBtn.id = `applyFilterBtn-${this.instanceId}`;
                applyBtn.textContent = "Apply";

                const clearBtn = document.createElement("button");
                clearBtn.className = "ui basic small button";
                clearBtn.id = `applyFilterClearBtn-${this.instanceId}`;
                clearBtn.textContent = "Clear";

                buttonGroupDiv.appendChild(applyBtn);
                buttonGroupDiv.appendChild(clearBtn);
                buttonFieldDiv.appendChild(buttonGroupDiv);

                fieldsDiv.appendChild(startFieldDiv);
                fieldsDiv.appendChild(endFieldDiv);
                fieldsDiv.appendChild(buttonFieldDiv);
                formDiv.appendChild(fieldsDiv);

                if (this.container) {
                    this.container.appendChild(formDiv);
                } else {
                    console.warn("Container not found!");
                }
            }
        }

        class FolderManager {
            constructor() {
                this.folderPicker = document.getElementById('folderPicker');
                this.imageList = document.getElementById('imageList');
                this.svgViewer = document.getElementById('svgViewer');
                this.dataViewer = document.getElementById('dataViewer');
                this.saveBtn = document.getElementById('saveBtn');
                this.viewToggle = document.getElementById('viewToggle');
                this.chartView = document.getElementById('chartView');
                this.imageView = document.getElementById('imageView');
                this.autoReloadToggle = document.getElementById('autoReloadToggle');
                this.cardGridToggleBool = document.getElementById('cardGridToggle');
                this.clearDates = document.getElementById('clearDates');

                this.modalHeader = document.getElementById('modal-header');
                this.modalContent = document.getElementById('modal-content');
                this.gridLabel = document.getElementById('gridLabel');
                this.stackToggle = document.getElementById('stackToggle');
                this.reloadBtn = document.getElementById('reloadBtn');
                this.folderName = document.getElementById('dirHandle');
                this.statsHtml = document.getElementById('stats-container');
                this.statsHtmlMain = document.getElementById('stats-container-main');
                this.statsHtmlMainHeaderStats = document.getElementById('stats-container-main-stats');
                this.summaryContainer = document.getElementById('summary-container');
                this.groupKeyTableFilter = document.getElementById('groupKey-table-filter');
                this.summaryHeader = document.getElementById('summary-header');
                this.systemHealthHtmlLabel = document.getElementById('system-health-label');
                this.sortBtn = document.getElementById('sortByDateBtn');
                this.progressData = document.getElementById('progressData')
                this.summaryChartCtx = document.getElementById('summaryChart')?.getContext('2d');
                this.timelineChartCtx = document.getElementById('timelineChart')?.getContext('2d');
                this.heartbeatChartCtx = document.getElementById('heartbeatChart').getContext('2d');
                this.cumulativeCountChartCtx = document.getElementById('cumulativeCountChart').getContext('2d');

                this.loadMoreBtn = document.getElementById("loadMoreBtn");
                this.imageDeck = document.getElementById('image-deck');
                this.playSlideshowBtn = document.getElementById('playSlideshowBtn');
                this.saved = JSON.parse(localStorage.getItem('savedFilenames') || '[]');
                this.applyFilterBtn = document.getElementById('applyFilterBtn');
                this.applyFilterClearBtn = document.getElementById('applyFilterClearBtn');
                this.startTimeInput = document.getElementById('startTimeInput');
                this.endTimeInput = document.getElementById('endTimeInput');

                this.select = document.getElementById('preset-select');
                this.button = document.getElementById('generate-btn');
                this.qrcodeContainer = document.getElementById('qrcode');
                this.bottomTitle = document.getElementById('bottom-title');

                this.dropNumSearch = document.getElementById('groupKey');
                this.clearDateBtn = document.getElementById('clearDateBtn');

                this.cardGridContainer = document.getElementById('cardGridContainer');
                this.cardGridInner = document.getElementById('cardGridInner');
                this.cardGridSpacerTop = document.getElementById('cardGridSpacerTop');
                this.cardGridSpacerBottom = document.getElementById('cardGridSpacerBottom');

                this.presets = [
                    {
                        en: "Machine Repeatedly Rejecting Parts\nThe system is currently rejecting most or all parts. Please investigate reject logic or sensor alignment.",
                        es: "Máquina rechazando piezas repetidamente"
                    },
                    {
                        en: "Operator Needs Assistance\nImmediate help required. The operator is unable to proceed due to an issue with the machine or process.",
                        es: "Operador necesita asistencia"
                    },
                    {
                        en: "Quality Hold, Do Not Operate\nThis machine is under quality review. Do not resume operation until cleared by QA or Engineering.",
                        es: "Retención por calidad, No operar"
                    },
                    {
                        en: "Engineering Currently Training the Machine\nEngineering team is configuring or learning machine behavior for optimization. Please do not interrupt.",
                        es: "Ingeniería entrenando la máquina"
                    },
                    {
                        en: "In Testing Phase , Use with Caution\nThe machine is undergoing testing. Results may be inconsistent. Only authorized personnel should operate.",
                        es: "En fase de prueba , Usar con precaución"
                    },
                    {
                        en: "Machine Offline for Maintenance\nThis machine is temporarily shut down for preventive or corrective maintenance.",
                        es: "Máquina fuera de línea por mantenimiento"
                    },
                    {
                        en: "Fault in Box Feeder/Loader Detected\nThere is an issue with the material feed or loading mechanism. Check for jams or misfeeds.",
                        es: "Falla detectada en el alimentador/cargador de cajas"
                    },
                    {
                        en: "Under Investigation by Engineering\nA technical issue has been reported and is being actively investigated by Engineering.",
                        es: "Bajo investigación por ingeniería"
                    },
                    {
                        en: "Machine in Calibration Mode\nDo not run production , the system is being calibrated for accuracy and alignment.",
                        es: "Máquina en modo de calibración"
                    },
                    {
                        en: "Material Issue Detected\nIncorrect or incompatible material detected. Verify material specs and replace if needed.",
                        es: "Problema de material detectado"
                    },
                    {
                        en: "Process Adjustment in Progress\nSettings or parameters are being modified for optimization. Please wait for completion.",
                        es: "Ajuste de proceso en curso"
                    },
                    {
                        en: "Temporarily Halted Due to Safety Concern\nA potential safety issue has been identified. Await clearance from Safety/Engineering.",
                        es: "Detenido temporalmente por motivo de seguridad"
                    },
                    {
                        en: "Rebooting , Wait for System Restart\nMachine is currently rebooting. Operation will resume shortly.",
                        es: "Reiniciando , Esperando reinicio del sistema"
                    },
                    {
                        en: "Waiting for Parts/Consumables\nMachine idle due to lack of materials or required consumables. Supply pending.",
                        es: "Esperando piezas/consumibles"
                    }
                ];

                this.filterString = '';
                this.search = null;
                this.dateFilter = null;
                this.selectedDate = null;
                this.timeSeriesData = [];
                this.summaryData = {};
                this.availableFilters = new Set();
                this.currentFilename = null;
                this.chartInstance = null;
                this.timelineChartInstance = null;
                this.cumulativeCountChartInstance = null;
                this.autoReloadInterval = null;
                this.dirHandle = null;
                this.dirSelectedHandle = 'FS';
                this.searchTheseNames = [];
                this.progressBar = 0;
                this.dates = [];

                this.colors = [
                    "red", "orange", "yellow", "olive", "green", "teal", "blue", "violet", "purple", "pink",
                    "grey", "black"
                ]

                this.slideshowInterval = null;
                this.slideshowIndex = 0;
                this.slideshowFiles = [];
                this.slideshowIndex = 0;
                this.slideshowTimer = null;
                this.slideshowSpeed = 3000; // default: 3 seconds
                this.startTime = null;
                this.endTime = null;
                this.rangestart = null;
                this.rangeend = null;

                this.calStart = null;
                this.calEnd = null;


                this.cachedFiles = []; // will store all parsed files after initial read
                this.isReloading = false;
                this.groupKey = [];
                this.arryInfo = null;
                this.sortByRecent = false; // default: no sorting
                this.updateProgress = 0;
                this.gridControl = { grid: ['three'], list: ['one', 'horizontal'] };

                this.isStacked = false;
                this.selectedCardData = null;
                this.trendVisualizer = null;
                this.updateSearch = this.updateSearch.bind(this);
                this.updatedCache = false;

                this.cardHeight = 404 * 3; // Estimate or measure this
                this.buffer = 6;      // Buffer before/after visible range

                this.ITEMS_PER_PAGE = 20;


                this.state = {
                    allResults: [],
                    nextStartAfter: null,
                    hasMore: true
                };

                this.visibleCardCount = Math.ceil(this.cardGridContainer.clientHeight / this.cardHeight);
                this.filteredFiles = null;
                this.init();

            }

            timeControlComponent(container, id) {
                const timeControl = new TimeFilterForm(container, id);
                timeControl.createForm();
            }

            animatedCounter(el, target) {

                let start = 0;
                const duration = 1000; // 1 second
                const startTime = performance.now();

                const update = (currentTime) => {
                    const progress = Math.min((currentTime - startTime) / duration, 1);
                    const value = Math.floor(start + (Number(target) - start) * progress);
                    el.textContent = value;

                    if (progress < 1) {
                        requestAnimationFrame(update);
                    }
                };

                requestAnimationFrame(update);
            }

            async init() {
                this.folderPicker?.addEventListener('click', () => this.selectFolder());
                this.stackToggle?.addEventListener('change', () => {
                    this.summaryHeader.innerText =
                        !this.isStacked ?
                            'Stacked Comparison of Field Values' :
                            'Grouped Comparison of Field Values'
                    this.isStacked = !this.isStacked;
                    this.renderSummaryChart();

                });
                this.reloadBtn?.addEventListener('click', () => this.readFolderContents());
                this.viewToggle?.addEventListener('change', () => this.toggleView());
                this.autoReloadToggle?.addEventListener('change', () => this.toggleAutoReload());
                this.loadMoreBtn?.addEventListener('click', () => this.loadMore(this.dirHandle));
                this.clearDateBtn?.addEventListener('click', () => this.clearDate())
                this.saveBtn?.addEventListener('click', () => this.toggleSave());
                this.cardGridView = document.getElementById('cardGridView');
                this.cardGridToggleBool?.addEventListener('change', () => this.imageGridSettings());
                this.imageDeck?.addEventListener('click', () => { if (this.dirHandle === null) { this.setFolder(); } });
                this.setupSlideshowControls();
                this.sortBtn?.addEventListener('click', () => {
                    this.sortByRecent = !this.sortByRecent;
                    this.sortBtn.innerHTML = this.sortByRecent ?
                        `<i class="sort amount down icon"></i>` :
                        `<i class="sort amount up icon"></i>`;
                    this.filterAndRenderFiles();
                });
                $('.ui.search').search({
                    source: [],
                    onSearchQuery: function (query) {
                        if (!query.trim()) {
                            // Reset the search results when query is empty
                            this.search = null; // If you have a custom reset function
                            this.filterAndRenderFiles();

                            return;
                        }

                        this.search = query;
                        this.filterAndRenderFiles();
                    }.bind(this)
                });
                $('.groupKey').dropdown({
                    onChange: function (value, text, $selectedItem) {
                        this.search = value;
                        this.filterAndRenderFiles();
                    }.bind(this)
                });
                $('#filterDropdown').dropdown();
                $('#deviceType').dropdown({
                    onChange: (e) => {
                        this.dirSelectedHandle = e;
                        this.filterAndRenderFiles();
                    }
                }).dropdown('set selected', 'FS');

                document.getElementById('deviceType').addEventListener('click', () => {
                    if (this.dirHandle === null) {
                        alert(`Please select the ${this.dirSelectedHandle} folder`)
                        this.setFolder();
                        if (!this.autoReloadInterval) {
                            this.autoReloadInterval = setInterval(() => {
                                if (this.dirHandle && !this.isReloading) {
                                    this.updatedCache = true;
                                    this.backgroundReloadCache();
                                }
                            }, 30000);
                        }

                    } else if (this.dirHandle.name !== this.dirSelectedHandle) {
                        alert(`Please select the ${this.dirSelectedHandle} folder`)
                        this.setFolder();
                        if (!this.autoReloadInterval) {
                            this.autoReloadInterval = setInterval(() => {
                                if (this.dirHandle && !this.isReloading) {
                                    this.updatedCache = true;
                                    this.backgroundReloadCache();
                                }
                            }, 30000);
                        }

                    }
                })

                $('.menu .item').tab();
                $('#progressBar').progress();
                $('#toast-progress').progress();
                $('.card-grid').checkbox();
                $(document).on('click', '.show-modal', function () {
                    $('.ui.overlay.fullscreen.modal').modal('show');
                });

                this.clearDates.addEventListener('click', () => {
                    this.clearDate();
                })

                this.applyFilterBtn.addEventListener('click', () => {
                    const startTimeStr = this.startTimeInput.value;
                    const endTimeStr = this.endTimeInput.value;

                    const baseDateStart = new Date(this.rangestart); // You already set this elsewhere
                    const baseDateEnd = new Date(this.rangeend); // You already set this elsewhere

                    if (startTimeStr) {
                        const [h, m] = startTimeStr.split(':');
                        const start1 = new Date(baseDateStart), start2 = new Date(baseDateStart);
                        start1.setHours(+h, +m, 0, 0);
                        start2.setHours(+h, +m, 0, 0);
                        this.startTime = { start1, start2 };
                    } else {
                        this.startTime = null;
                    }

                    if (endTimeStr) {
                        const [h, m] = endTimeStr.split(':');
                        const end1 = new Date(baseDateEnd), end2 = new Date(baseDateEnd);
                        end1.setHours(+h, +m, 0, 0);
                        end2.setHours(+h, +m, 0, 0);
                        this.endTime = { end1, end2 };
                    } else {
                        this.endTime = null;
                    }

                    this.filterAndRenderFiles();
                });

                window.addEventListener('scroll', () => {
                    const scrollTop = window.scrollY || document.documentElement.scrollTop;
                    this.visibleCardCount = Math.ceil(this.cardGridContainer.clientHeight / this.cardHeight);

                    const startIndex = Math.max(0, Math.floor(scrollTop / this.cardHeight) - this.buffer);
                    const endIndex = Math.min(
                        this.filteredFiles.length,
                        startIndex + this.visibleCardCount + this.buffer * 2
                    );

                    this.renderVirtualCards(startIndex, endIndex);
                });

                this.applyFilterClearBtn.addEventListener('click', () => {

                    this.startTimeInput.value = null;
                    this.endTimeInput.value = null;

                    this.startTime = null;
                    this.endTime = null;

                    /* this.renderTimelineChart();
                    this.renderCardGrid(); */
                    this.filterAndRenderFiles();
                });

                this.setCalendarDatesToDefault();
                this.setupDateDropdown();
                this.setupCalendar();
                this.showLoader();
                this.renderStats();
                this.getHealthIndicator();
                this.qrMaker();
                this.searchNumDropdown();
                this.trendVisualizer = new TrendVisualizer('trend-container', []);
                this.trendVisualizerCards = new TrendVisualizerCards('trend-container-card', [], this.animatedCounter);

                this.cachedFiles = await this.queryRecentFilesByDirHandle('FS')

                await this.loadTimeSeriesData();
                await this.loadGroupKeyData();
                await this.loadAvailableFiltersData();
                await this.filterAndRenderFiles();

                setTimeout(() => this.hideLoader(), 2000);
            }

            extractLabelValue(labels, key) {
                const label = labels.find(l => l.startsWith(`${key}=`));
                return label ? parseInt(label.split('=')[1], 10) : 0;
            }

            analyzeTrends(currentGroupKey, targetDate) {
                let totalFail = 0;
                let totalPass = 0;
                const classificationFailures = {};

                this.cachedFiles.forEach(item => {
                    const groupKey = item.groupKey;
                    const date = new Date(item.date).toISOString().split('T')[0];

                    if (groupKey !== currentGroupKey || date !== targetDate) return;

                    const fail = this.extractLabelValue(item.labels, 'Job.Fail');
                    const pass = this.extractLabelValue(item.labels, 'Job.Pass');

                    totalFail += fail;
                    totalPass += pass;

                    if (fail > 0) {
                        item.labels.forEach(label => {
                            if (label.startsWith('Classify_') && !label.includes('OK')) {
                                classificationFailures[label] = (classificationFailures[label] || 0) + 1;
                            }
                        });
                    }
                });

                const mostSeenFailure = Object.entries(classificationFailures).sort((a, b) => b[1] - a[1])[0];

                const fTRatio = totalPass > 0 ? +(totalFail / totalPass).toFixed(2) : '0.00';
                const color =
                    (fTRatio === '0.00') ? "blue" :
                        (fTRatio < 0.05) ? "green" :
                            (fTRatio <= 0.15) ? "orange" : "red";

                const iconDetails =
                    (fTRatio === '0.00') ? "ban" :
                        (fTRatio < 0.05) ? "check circle" :
                            (fTRatio < 0.15) ? "exclamation triangle" : "exclamation circle";

                return {
                    date: targetDate,
                    failToPassRatio: fTRatio,
                    color,
                    iconDetails
                };
            }

            updateSearch(response) {
                this.search = response;
                this.filterAndRenderFiles();
            }

            setCalendarDatesToDefault() {
                this.rangestart = new Date('2000-01-01T00:00:00.000Z').toISOString();
                this.rangeend = new Date().toISOString();
            }

            searchNumDropdown() {
                const f = this.cachedFiles.filter(item => this.matchesFilters(item));
                this.dropNumSearch.innerHTML = '';
                this.dropNumSearch.innerHTML =
                    this.groupKey.map(item => f.some(i => i.groupKey === item) ? `<div class="item" data-value="${item}">${item}</div>` : null).join('');
            }

            qrMaker() {
                this.presets.forEach((preset, index) => {
                    const option = document.createElement('option');
                    const titleText = preset.en.split('\n')[0];
                    option.value = index;
                    option.textContent = titleText;
                    option.setAttribute('data-fulltext', preset.en);
                    option.title = `${titleText} / ${preset.es}`;
                    this.select.appendChild(option);
                });

                this.button.addEventListener('click', () => {
                    const selectedOption = this.select.options[this.select.selectedIndex];
                    if (!selectedOption || !selectedOption.value) {
                        alert('Please select a preset message');
                        return;
                    }

                    const fullText = selectedOption.getAttribute('data-fulltext');
                    const titleText = fullText.split('\n')[0] + " / " + this.presets.find(item => fullText.split('\n')[0])?.es;

                    // Clear previous QR
                    this.qrcodeContainer.innerHTML = '';

                    // Generate QR code
                    new QRCode(this.qrcodeContainer, {
                        text: fullText,
                        width: 200,
                        height: 200,
                        colorDark: '#000000',
                        colorLight: '#ffffff',
                        correctLevel: QRCode.CorrectLevel.H
                    });

                    // Show title at the bottom
                    this.bottomTitle.textContent = titleText;

                    // Trigger print
                    setTimeout(() => {
                        window.print();
                    }, 500);
                });

            }

            getHealthIndicator() {
                const errorRate = this.getErrorRate();

                let healthStatus = '';
                let color = '';
                let icon = '';

                if (errorRate === 0) {
                    healthStatus = 'Excellent';
                    color = 'green';
                    icon = 'check circle';
                } else if (errorRate <= 5) {
                    healthStatus = 'Good';
                    color = 'olive';
                    icon = 'thumbs up';
                } else if (errorRate <= 15) {
                    healthStatus = 'Fair';
                    color = 'yellow';
                    icon = 'exclamation circle';
                } else if (errorRate <= 30) {
                    healthStatus = 'Poor';
                    color = 'orange';
                    icon = 'warning sign';
                } else {
                    healthStatus = 'Critical';
                    color = 'red';
                    icon = 'times circle';
                }

                this.systemHealthHtmlLabel.innerHTML = `
    <div class="ui icon ${color} message">
        <i class="${icon} icon"></i>
        <div class="content">
            <div class="header">
                System Health: ${healthStatus}
            </div>
            <p>Error Rate: ${errorRate.toFixed(2)}%</p>
        </div>
    </div>
`;

            }

            getRecentActivity(days = 7) {
                const cutoff = new Date();
                cutoff.setDate(cutoff.getDate() - days);
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });
                return filteredItems.filter(item => new Date(item.date) >= cutoff);
            }

            getErrorRate() {
                let totalFails = 0, totalPasses = 0;
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });
                filteredItems.forEach(item => {

                    item.labels.forEach(label => {
                        if (label.startsWith("Job.Fail=")) totalFails += parseInt(label.split("=")[1]);
                        if (label.startsWith("Job.Pass=")) totalPasses += parseInt(label.split("=")[1]);
                    });
                });

                const total = totalFails + totalPasses;
                return total === 0 ? 0 : (totalFails / total) * 100;
            }

            getMostCommonPredictedClass() {
                const classCounts = {};
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });
                filteredItems.forEach(item => {
                    item.labels.forEach(label => {
                        if (label.includes("PredictedClass=") && !label.includes("OK")) {
                            const cls = label.split("=")[1];
                            classCounts[cls] = (classCounts[cls] || 0) + 1;
                        }
                    });
                });

                const sorted = Object.entries(classCounts).sort((a, b) => b[1] - a[1]);
                return sorted[0] || null;
            }

            getTopGroupKeys(n = 5) {
                const groupMap = {};
                const filteredItems = this.cachedFiles.filter(item => this.matchesFilters(item));

                filteredItems.forEach(item => {
                    groupMap[item.groupKey] = (groupMap[item.groupKey] || 0) + 1;
                });

                return Object.entries(groupMap)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, n)
                    .map(([groupKey, count]) => ({ groupKey, count }));
            }

            findThisDate(event) {
                const buttonElement = event.currentTarget;
                const dateValue = buttonElement.getAttribute('data-date');

                // Create a date in local time (year, monthIndex (0-based), day)
                const [year, month, day] = dateValue.split('-').map(Number);
                const localDate = new Date(year, month - 1, day);

                this.rangestart = localDate.toString();
                this.rangeend = localDate.toString();
                this.filterAndRenderFiles();

            }

            insertGroupedDates(page = 1, rowsPerPage = 10) {
                const grouped = this.groupDataByKey();
                const container = this.groupKeyTableFilter;
                if (!container) return;

                container.innerHTML = ''; // Clear previous content

                // Flatten grouped data
                const allRows = [];
                grouped.forEach(group => {
                    group.data.forEach(dataItem => {
                        allRows.push({ groupName: group.groupName, ...dataItem });
                    });
                });

                const totalPages = Math.ceil(allRows.length / rowsPerPage);
                const start = (page - 1) * rowsPerPage;
                const end = start + rowsPerPage;
                const pagedRows = allRows.slice(start, end);

                // Create table
                const table = document.createElement('table');
                table.className = 'ui single line table left aligned  very short scrolling ';

                // Thead
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                ['Part #', 'Date', 'Fail/Pass Ratio', 'Action'].forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Tbody
                const tbody = document.createElement('tbody');
                pagedRows.forEach(dataItem => {
                    const date = dataItem.date;
                    const [year, month, day] = date.split('-').map(Number);
                    const dateFormatted = new Date(year, month - 1, day);
                    const formatted = new Intl.DateTimeFormat('en-US', {
                        year: '2-digit',
                        month: '2-digit',
                        day: '2-digit'
                    }).format(dateFormatted);

                    const tr = document.createElement('tr');

                    // Group name
                    const tdGroup = document.createElement('td');
                    tdGroup.textContent = dataItem.groupName;
                    tr.appendChild(tdGroup);

                    // Date
                    const tdDate = document.createElement('td');
                    tdDate.textContent = formatted;
                    tr.appendChild(tdDate);

                    // Ratio
                    const tdRatio = document.createElement('td');
                    tdRatio.textContent = `${(dataItem.failToPassRatio * 100).toFixed(0)}%`;
                    tdRatio.classList = `${dataItem.color}`;
                    tr.appendChild(tdRatio);

                    // Action
                    const tdAction = document.createElement('td');
                    const button = document.createElement('button');
                    button.className = `ui icon popUp-Btn button `;
                    button.setAttribute('data-date', date);
                    button.onclick = (event) => { this.findThisDate(event) };

                    const tdAction2 = document.createElement('td');
                    const button2 = document.createElement('button');
                    button2.className = `ui icon button red `;
                    button2.onclick = (event) => { this.clearDate() };


                    const icon2 = document.createElement('i');
                    icon2.className = `calendar minus icon`;
                    button2.appendChild(icon2);

                    const icon = document.createElement('i');
                    icon.className = `search icon`;
                    button.appendChild(icon);

                    tdAction.appendChild(button);
                    tdAction2.appendChild(button2);

                    const btnGroup = document.createElement('div');
                    btnGroup.className = 'ui buttons circular '
                    btnGroup.appendChild(tdAction);
                    btnGroup.appendChild(tdAction2);

                    tr.appendChild(btnGroup);

                    tbody.appendChild(tr);
                });

                table.appendChild(tbody);
                container.appendChild(table);

                // Pagination controls
                const pagination = document.createElement('div');
                pagination.className = 'ui pagination menu';

                for (let i = 1; i <= totalPages; i++) {
                    const pageItem = document.createElement('a');
                    pageItem.className = `item${i === page ? ' active' : ''}`;
                    pageItem.textContent = i;
                    pageItem.onclick = () => this.insertGroupedDates(i, rowsPerPage);
                    pagination.appendChild(pageItem);
                }

                container.appendChild(pagination);

                $('.popUp-Btn').popup();
            }

            groupDataByKey() {
                const grouped = {};
                const filteredItems = this.cachedFiles.filter(item => this.matchesFilters(item));

                for (const item of filteredItems) {
                    const key = item.groupKey;
                    const dateOnly = item.date.split('T')[0];

                    if (!grouped[key]) {
                        grouped[key] = new Set();
                    }

                    grouped[key].add(dateOnly);
                }

                return Object.entries(grouped).map(([groupName, dateSet]) => {
                    const data = Array.from(dateSet).sort().map(date => {
                        const ratioData = this.analyzeTrends(groupName, date);
                        return {
                            date,
                            ...ratioData
                        };
                    });

                    return {
                        groupName,
                        data
                    };
                });
            }

            renderSummaryContainer(recent, errRate, commonClass) {
                // Root grid
                const grid = document.createElement('div');
                grid.className = 'ui grid';

                // --- Row 1: Summary Section ---
                const row1 = document.createElement('div');
                row1.className = 'row';

                const col1 = document.createElement('div');
                col1.className = 'column sixteen wide';

                // Summary Header
                const summaryHeader = document.createElement('h3');
                summaryHeader.className = 'ui header attached top inverted';
                summaryHeader.textContent = 'Summary';

                // Summary Segment
                const summarySegment = document.createElement('div');
                summarySegment.className = 'ui segment attached bottom padded';

                const p1 = document.createElement('p');
                p1.innerHTML = `<strong>Recent Activity (7d):</strong> ${recent} items`;

                const p2 = document.createElement('p');
                p2.innerHTML = `<strong>Error Rate:</strong> ${errRate}%`;

                const p3 = document.createElement('p');
                p3.innerHTML = `<strong>Top Predicted Class:</strong> ${commonClass}`;

                // Append paragraphs to segment
                summarySegment.appendChild(p1);
                summarySegment.appendChild(p2);
                summarySegment.appendChild(p3);

                // Bottom Header (timestamp)
                const dateHeader = document.createElement('h4');
                dateHeader.className = 'ui header attached bottom grey';
                dateHeader.textContent = new Date().toLocaleString();

                // Assemble column 1
                col1.appendChild(summaryHeader);
                col1.appendChild(summarySegment);
                col1.appendChild(dateHeader);
                row1.appendChild(col1);

                // --- Row 2: Available Dates Section ---
                const row2 = document.createElement('div');
                row2.className = 'row';

                const col2 = document.createElement('div');
                col2.className = 'column sixteen wide';
                col2.id = 'dateList';

                // Dates Header
                const datesHeader = document.createElement('h3');
                datesHeader.className = 'ui header top';
                datesHeader.textContent = 'Available Dates';

                // Available Dates Container
                const datesDiv = document.createElement('div');
                datesDiv.className = 'ui attached bottom available-dates';

                // Assemble column 2
                col2.appendChild(datesHeader);
                col2.appendChild(datesDiv);
                row2.appendChild(col2);

                // --- Append both rows to grid ---
                grid.appendChild(row1);
                grid.appendChild(row2);

                // Append the grid to a container in your document
                // Example: document.getElementById('summary-container').appendChild(grid);
                this.summaryContainer.appendChild(grid);

            }

            renderSummary() {
                const recent = this.getRecentActivity(7).length;
                const errRate = this.getErrorRate().toFixed(2);
                const commonClass = this.getMostCommonPredictedClass()?.[0] || "N/A";
                // this.renderSummaryContainer();
            }

            toastMessage({ message, title, displayTime, classData, position }) {
                $.toast({
                    title,
                    message,
                    displayTime,
                    position,
                    showProgress: 'bottom',
                    classProgress: 'red',
                    class: classData
                });
            }

            async backgroundReloadCache() {
                if (!this.dirHandle || !this.updatedCache || this.isReloading) return;

                this.isReloading = true; // Lock
                this.updatedCache = false; // Reset update trigger

                try {
                    console.log('[AutoReload] Cache check started at', new Date().toLocaleTimeString());

                    this.toastMessage({
                        title: 'Cache check started!',
                        message: 'Loading...',
                        position: 'bottom right'
                    });

                    const groupedFiles = {};
                    const now = new Date();
                    const allFiles = await this.getAllFilesAndFolders(this.dirHandle, false);
                    const existingNames = await this.getAllFileNamesByKey();
                    const newFilePairs = [];
                    let count = 0;

                    for (const fileObj of allFiles) {
                        const { svgHandle } = fileObj;
                        const name = svgHandle.name;
                        const cached = existingNames.has(svgHandle.name);

                        if (!cached) {
                            newFilePairs.push(fileObj);
                        } else {
                            const group = groupedFiles[cached.groupKey] ||= [];
                            group.push(cached);
                        }
                    }

                    console.log('[AutoReload] File scan completed at', new Date().toLocaleTimeString());

                    const newFileNames = new Set(newFilePairs.map(f => f.svgHandle.name));
                    const existingFileNames = new Set(this.cachedFiles.map(f => f.name));

                    const added = newFilePairs.filter(f => !existingFileNames.has(f.svgHandle.name));
                    const removed = this.cachedFiles.filter(f => !existingFileNames.has(f.name));

                    let updated = false;

                    if (added.length > 0) {
                        const addedGrouped = {};
                        const results = await this.processBatch(added, addedGrouped, now, false);
                        count = results;
                        updated = true;
                        console.log('[AutoReload] New files processed at', new Date().toLocaleTimeString());
                    }

                    if (removed.length > 0) {
                        this.cachedFiles = this.cachedFiles.filter(f => !removed.some(r => r.name === f.name));
                        updated = false;
                        console.log('[AutoReload] Removed missing files at', new Date().toLocaleTimeString());
                    }

                    if (updated) {
                        this.filterAndRenderFiles();
                        this.showNewLabel({ live: true, count: count });

                        this.toastMessage({
                            title: 'Cache updated!',
                            message: 'Files reloaded.',
                            displayTime: 2000,
                            classData: 'success',
                            position: 'bottom right'
                        });

                        console.log('[AutoReload] Cache updated at', new Date().toLocaleTimeString());
                    } else {
                        this.showNewLabel({ live: false });

                        this.toastMessage({
                            title: 'No cache update needed!',
                            message: 'Everything is up to date.',
                            displayTime: 3000,
                            position: 'bottom right'
                        });

                        console.log('[AutoReload] No update needed at', new Date().toLocaleTimeString());
                    }
                } catch (err) {
                    console.error('[AutoReload] Error during cache reload:', err);
                } finally {
                    this.isReloading = false; // Unlock
                }
            }


            async backgroundReloadCacheOld() {
                if (!this.dirHandle) return;
                if (!this.updatedCache) return;


                console.log('[AutoReload] Cache check started at', new Date().toLocaleTimeString());

                this.toastMessage({
                    title: 'Cache check started !',
                    message: 'Loading',
                    position: 'bottom right'
                });

                const groupedFiles = {};
                const now = new Date();
                const newFileHandles = [];

                // Scan all .svg files and compare with cache
                for await (const entry of this.dirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.endsWith('.svg')) {
                        const cached = await this.isFileInDB(entry.name);
                        if (!cached) {
                            newFileHandles.push(entry);
                        } else {
                            const group = groupedFiles[cached.groupKey] ||= [];
                            group.push(cached);
                        }
                    }
                }

                console.log('[AutoReload] File scan completed at', new Date().toLocaleTimeString());

                // Compare current cache with new scan
                const newFileNames = new Set(newFileHandles.map(f => f.name));
                const existingFileNames = new Set(this.cachedFiles.map(f => f.name));

                const addedFiles = newFileHandles.filter(f => !existingFileNames.has(f.name));
                const removedFiles = this.cachedFiles.filter(f => !newFileNames.has(f.name));

                let updated = false;

                // === Process New Files in Batch ===
                if (addedFiles.length > 0) {
                    const addedGroupedFiles = {};
                    updated = await this.processBatch(addedFiles, addedGroupedFiles, now, false) ?? false;

                    // Merge newly processed files into cachedFiles
                    for (const key in addedGroupedFiles) {
                        for (const fileObj of addedGroupedFiles[key]) {
                            this.cachedFiles.push(fileObj);
                        }
                    }

                    console.log('[AutoReload] New files processed at', new Date().toLocaleTimeString());
                }

                // === Handle Removed Files ===
                if (removedFiles.length > 0) {
                    this.cachedFiles = this.cachedFiles.filter(f => !removedFiles.some(r => r.name === f.name));
                    updated = true;

                    console.log('[AutoReload] Removed missing files at', new Date().toLocaleTimeString());

                }

                // === Update UI if any changes ===
                if (updated) {
                    this.filterAndRenderFiles();
                    console.log('[AutoReload] Cache updated at', new Date().toLocaleTimeString());
                    this.showNewLabel({ live: true, count: this.cachedFiles.length });

                    this.toastMessage({
                        title: 'Cache updated!',
                        message: 'Loading',
                        displayTime: 5000,
                        classData: 'success',
                        position: 'bottom attached'
                    });
                } else {
                    console.log('[AutoReload] No cache update needed at', new Date().toLocaleTimeString());
                    this.showNewLabel({ live: false });

                    this.toastMessage({
                        title: 'No cache update needed!',
                        message: 'Loading',
                        displayTime: 5000,
                        position: 'bottom attached'
                    });
                }

                this.updatedCache = !this.updatedCache;
            }

            async selectFolder() {
                try {
                    this.setCalendarDatesToDefault();
                    this.dirHandle = await window.showDirectoryPicker();
                    await this.readFolderContents();
                    this.folderName.innerHTML = `Folder:${this.dirHandle.name}` || 'Folder';


                } catch (e) {
                    console.error("Folder selection cancelled or failed:", e);
                }
            }

            async setFolder() {
                try {
                    this.setCalendarDatesToDefault();
                    this.dirHandle = await window.showDirectoryPicker();
                    this.folderName.innerHTML = `Folder:${this.dirHandle.name}` || 'Folder';


                } catch (e) {
                    console.error("Folder selection cancelled or failed:", e);
                }
            }

            startSlideshow() {
                if (this.slideshowInterval) {
                    clearInterval(this.slideshowInterval);
                    this.slideshowInterval = null;
                    document.getElementById('playSlideshowBtn').textContent = '▶️ Play Slideshow';
                    return;
                }

                this.slideshowFiles = this.cachedFiles.filter(file => {
                    return this.passesDateFilter(file.date) &&
                        (!this.filterString || file.labels.includes(this.filterString)) &&
                        (document.getElementById('showTrainedToggle')?.checked || !this.saved.includes(file.name));
                });

                if (this.slideshowFiles.length === 0) {
                    alert('No files to show in slideshow.');
                    return;
                }

                this.slideshowIndex = 0;
                document.getElementById('playSlideshowBtn').textContent = '⏸️ Stop Slideshow';

                this.slideshowInterval = setInterval(() => {
                    const file = this.slideshowFiles[this.slideshowIndex];
                    this.loadImage(file.name, file.content);

                    this.slideshowIndex = (this.slideshowIndex + 1) % this.slideshowFiles.length;
                }, 3000); // Change image every 3 seconds
            }

            setupSlideshowControls() {
                document.getElementById('playBtn').onclick = () => this.startSlideshow();
                document.getElementById('pauseBtn').onclick = () => this.stopSlideshow();
                document.getElementById('nextBtn').onclick = () => this.nextSlide();
                document.getElementById('prevBtn').onclick = () => this.prevSlide();

                document.querySelectorAll('#slideshowControls .item[data-speed]').forEach(item => {
                    item.onclick = () => {
                        this.slideshowSpeed = parseInt(item.getAttribute('data-speed'));
                        if (this.slideshowTimer) {
                            this.stopSlideshow();
                            this.startSlideshow(); // restart with new speed
                        }
                    };
                });
            }

            startSlideshow() {
                if (!this.cachedFiles.length) return;
                this.stopSlideshow();
                this.slideshowTimer = setInterval(() => this.nextSlide(), this.slideshowSpeed);
            }

            stopSlideshow() {
                if (this.slideshowTimer) {
                    clearInterval(this.slideshowTimer);
                    this.slideshowTimer = null;
                }
            }

            nextSlide() {
                if (!this.cachedFiles.length) return;
                this.slideshowIndex = (this.slideshowIndex + 1) % this.cachedFiles.length;
                const file = this.cachedFiles[this.slideshowIndex];
                this.loadImage(file.name, file.content);
            }

            prevSlide() {
                if (!this.cachedFiles.length) return;
                this.slideshowIndex = (this.slideshowIndex - 1 + this.cachedFiles.length) % this.cachedFiles.length;
                const file = this.cachedFiles[this.slideshowIndex];
                this.loadImage(file.name, file.content);
            }

            async buildCardContent(card, file) {

                const imageDiv = await this.loadImageObs(file);


                const contentDiv = document.createElement('div');
                contentDiv.className = 'content';

                const extraContentDiv = document.createElement('div');
                extraContentDiv.className = ' extra content';

                const headerDiv = document.createElement('div');
                headerDiv.className = 'header';
                headerDiv.textContent = `PN: ${file.name.split('_')[0]} | ID: ${file.name.split('_')[2].replace('.svg', '')}`;

                const metaDiv = document.createElement('div');
                metaDiv.className = 'meta right floated';

                //const svgHandle = await this.dirHandle.getFileHandle(file.name);
                // const svgFile = await svgHandle.getFile();
                // const date = new Date(svgFile.lastModified);

                const date = new Date(file.date);

                const dateFormatted = date.toLocaleDateString();

                const timeFormatted = date.toLocaleTimeString([], {
                    hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true
                });
                metaDiv.textContent = `${dateFormatted} ${timeFormatted}`;

                const descDiv = document.createElement('div');
                descDiv.className = 'description';

                const table = document.createElement('table');
                table.className = 'ui  basic table stackable';

                const tbody = document.createElement('tbody');
                file.content.split(',').forEach(entry => {
                    const [key, value] = entry.split(':');
                    if (key && value) {
                        const row = document.createElement('tr');
                        row.innerHTML = `<td>${key.trim()}</td><td>${value.trim()}</td>`;
                        tbody.appendChild(row);
                    }
                });

                const lineByLine = document.createElement('div');
                lineByLine.className = 'description';
                const list = document.createElement('div');
                list.className = 'ui  list  '

                let iconType = null, iconText = '';

                file.content.split(',').forEach(entry => {
                    const [key, value] = entry.split(':');
                    if (key && value) {

                        const row = document.createElement('div');
                        row.className = 'item'
                        row.innerHTML = `<p>${key.trim()}:${value.trim()}</p>`;
                        list.appendChild(row);

                        if (key.includes('Fail'))
                            iconType = (key.includes('Fail') && value.includes('1')) ? 'exclamation triangle red' : 'check green';
                    }
                });

                const moreInfoBtn = document.createElement('i');
                moreInfoBtn.className = `${iconType} icon`;

                const modalBtn = document.createElement('i');
                modalBtn.className = `show-modal search plus icon`;

                lineByLine.append(list);
                descDiv.appendChild(lineByLine);

                contentDiv.appendChild(headerDiv);
                extraContentDiv.appendChild(metaDiv);
                extraContentDiv.appendChild(moreInfoBtn);
                extraContentDiv.appendChild(modalBtn);
                contentDiv.appendChild(descDiv);

                card.innerHTML = '';
                card.appendChild(imageDiv);
                card.appendChild(contentDiv);
                card.appendChild(extraContentDiv)
            }

            async buildImageCardContent(card, file) {

                const imageDiv = await this.loadImageObs(file);
                card.innerHTML = '';
                card.appendChild(imageDiv);

            }

            async runBatched(tasks, batchSize = 21) {
                let index = 0;
                while (index < tasks.length) {
                    const batch = tasks.slice(index, index + batchSize);
                    await Promise.allSettled(batch.map(task => task()));
                    index += batchSize;
                }
            }

            async renderCardGrid1() {
                const filteredFiles = this.getFilteredFiles().filter(file =>
                    this.isWithinTimeWindow(file.date)
                );

                this.filteredFiles = filteredFiles; // Cache for use in scroll
                this.renderVirtualCards(0, this.visibleCardCount + this.buffer * 2); // Initial render
            }

            renderVirtualCards1(startIndex, endIndex) {
                this.cardGridInner.innerHTML = '';

                for (let i = startIndex; i < endIndex; i++) {
                    const file = this.filteredFiles[i];
                    const index = this.cachedFiles.indexOf(file);
                    if (index === -1) continue;

                    const card = document.createElement('div');
                    card.className = 'ui placeholder'; //card.className = 'ui small card loading';
                    card.dataset.index = index;

                    // Placeholder
                    card.innerHTML = `<div class="image"></div>` //`<div class="content"><p>Loading...</p></div>`;

                    this.cardGridInner.appendChild(card);
                }

                // Spacer divs to simulate full height
                this.cardGridSpacerTop.style.height = `${startIndex * this.cardHeight}px`;
                this.cardGridSpacerBottom.style.height = `${(this.filteredFiles.length - endIndex) * this.cardHeight}px`;

                this.observeLazyCards(); // Attach observer to only visible cards
            }

            observeLazyCards1() {
                const observer = new IntersectionObserver(async (entries) => {
                    const tasks = entries.map(entry => async () => {
                        const card = entry.target;
                        const index = parseInt(card.dataset.index);
                        const file = this.cachedFiles[index];

                        if (!file) return;

                        if (entry.isIntersecting) {
                            if (card.dataset.loaded === 'true') return;

                            card.dataset.loaded = 'true';


                            try {
                                card.onclick = () => this.loadImage(file.name, file.content);
                                await this.buildCardContent(card, file);
                                card.classList.remove('loading')
                            } catch (err) {
                                console.warn(`Failed to load content for card ${file?.name}:`, err);
                            }

                        } else {
                            if (card.dataset.loaded === 'true') {
                                this.unloadCardContent(card);
                                delete card.dataset.loaded;
                            }
                        }
                    });

                    await this.runBatched(tasks, 21); // Load/unload in batches
                }, {
                    root: this.cardGridInner,
                    rootMargin: '20px',
                    threshold: 0.1
                });

                this.cardGridInner.querySelectorAll('.ui.card').forEach(card => {
                    observer.observe(card);
                });
            }

            unloadCardContent(card) {
                card.classList.add('loading');
                card.innerHTML = `<div class="content"><p>Reloading...</p></div>`;
                card.onclick = null;
            }

            async renderCardGrid() {
                this.cardGridContainer.innerHTML = '';
                const found = await this.getFilteredFiles();
                const filteredFiles = found.filter(item => {
                    return this.isWithinTimeWindow(item.date);
                });
                if (this.search === null) {
                    this.cardGridContainer.innerHTML = `
    <div style="display: flex; justify-content: center; align-items: center; height: 100%;">
        <div class="ui warning message huge">
            <i class="exclamation triangle icon"></i>
            <div class="header">
                Selection Required
            </div>
            Please select a part number or date to view the images.
        </div>
    </div>
    `;
                    return;
                }

                filteredFiles.forEach((file, index) => {

                    const card = document.createElement('div');
                    card.className = 'ui mini card loading';
                    card.dataset.index = filteredFiles.indexOf(file); // Keep original index
                    // Placeholder content
                    card.innerHTML = `<div class="content"><p>Loading...</p></div>`;

                    this.cardGridContainer.appendChild(card);
                });

                this.observeLazyCards();

            }

            observeLazyCards() {
                const observer = new IntersectionObserver(async (entries) => {

                    const tasks = entries.map(entry => async () => {
                        const card = entry.target;
                        const index = parseInt(card.dataset.index);
                        const file = this.cachedFiles[index];


                        if (entry.isIntersecting) {
                            // LOAD CARD
                            if (!file || card.dataset.loaded === 'true') return;

                            card.dataset.loaded = 'true';

                            try {
                                card.onclick = () => {
                                    this.loadImage(file.name, file.content);
                                };
                                await this.buildImageCardContent(card, file);  //this.buildCardContent(card, file);
                                card.classList.remove('loading');
                            } catch (err) {
                                console.warn(`Failed to build content for card ${file?.name}:`, err);
                            }

                        } else {
                            // UNLOAD CARD
                            if (card.dataset.loaded === 'true') {
                                this.unloadCardContent(card);
                                delete card.dataset.loaded;
                            }
                        }
                    });

                    await this.runBatched(tasks, 9); // Process in batches
                }, {
                    root: null,
                    rootMargin: '20px',
                    threshold: 0.1
                });

                this.cardGridContainer.querySelectorAll('.ui.card').forEach(card => {
                    observer.observe(card);
                });
            }

            async generateSvgBlobFromFileName(filename) {
                try {
                    const svgHandle = await this.dirHandle.getFileHandle(filename);
                    const svgFile = await svgHandle.getFile();
                    let svgText = await svgFile.text();

                    // Optional: handle BMP embedding
                    const bmpMatch = svgText.match(/xlink:href=['"]([^'"]+\.bmp)['"]/i);
                    if (bmpMatch && bmpMatch[1]) {
                        try {
                            const bmpHandle = await this.dirHandle.getFileHandle(bmpMatch[1]);
                            const bmpFile = await bmpHandle.getFile();
                            const bmpBuffer = await bmpFile.arrayBuffer();
                            const bmpBase64 = this.arrayBufferToBase64(bmpBuffer);

                            const dataUri = `data:image/bmp;base64,${bmpBase64}`;
                            svgText = svgText.replace(bmpMatch[0], `xlink:href="${dataUri}"`);
                        } catch (err) {
                            console.warn(`⚠️ BMP not found: ${bmpMatch[1]}`, err);
                        }
                    }


                    return new Blob([svgText], { type: 'image/svg+xml' });
                } catch (e) {
                    console.error('Error generating SVG blob:', e);
                    return null;
                }
            }

            async showPreview(filename, event) {
                this.hidePreview(); // always clear previous

                this.previewHovering = true;

                // Delay slightly to avoid flicker on fast moves
                this.previewDelay = setTimeout(async () => {
                    if (!this.previewHovering) return; // if mouse already left

                    const blob = await this.generateSvgBlobFromFileName(filename);
                    if (!blob) return;

                    const preview = document.createElement('div');
                    preview.className = 'image-preview-popup';
                    preview.style.position = 'fixed';
                    preview.style.zIndex = 9999;
                    preview.style.border = '1px solid #ccc';
                    preview.style.background = '#fff';
                    preview.style.padding = '5px';
                    preview.style.boxShadow = '0 0 10px rgba(0,0,0,0.3)';
                    preview.style.maxWidth = '80vw';
                    preview.style.maxHeight = '80vh';
                    preview.style.pointerEvents = 'none';

                    const object = document.createElement('object');
                    object.type = 'image/svg+xml';
                    object.data = URL.createObjectURL(blob);
                    object.style.width = '500px';
                    object.style.height = 'auto';
                    preview.appendChild(object);

                    document.body.appendChild(preview);
                    this.previewElement = preview;

                    // Position
                    preview.style.left = `${event.clientX + 15}px`;
                    preview.style.top = `${event.clientY + 15}px`;

                    // Hide after 30 sec
                    this.previewTimeout = setTimeout(() => {
                        this.hidePreview();
                    }, 30000);
                }, 200); // slight delay
            }

            hidePreview() {
                if (this.previewTimeout) {
                    clearTimeout(this.previewTimeout);
                    this.previewTimeout = null;
                }
                if (this.previewElement) {
                    this.previewElement.remove();
                    this.previewElement = null;
                }
            }

            imageGridSettings() {
                if (this.cardGridToggleBool.checked) {
                    this.gridControl.grid.map(i => this.cardGridContainer.classList.remove(i))
                    this.gridControl.list.map(i => this.cardGridContainer.classList.add(i));
                } else {
                    this.gridControl.list.map(i => this.cardGridContainer.classList.remove(i))
                    this.gridControl.grid.map(i => this.cardGridContainer.classList.add(i));
                }
            }

            matchesFilters(item) {
                const searchTerm = this.search?.toLowerCase();

                // Text search
                const matchesSearch = !this.search || (
                    item.name.toLowerCase().includes(searchTerm) ||
                    item.labels.some(label => label.toLowerCase().includes(searchTerm))
                );

                // Date filter
                const matchesDate = this.passesDateFilter(item.date);

                // Label filter
                const matchesLabel = !this.filterString || item.labels.includes(this.filterString);

                return matchesSearch && matchesDate && matchesLabel;
            }

            matchesFiltersNoLabel(item) {
                const searchTerm = this.search?.toLowerCase();

                // Text search
                const matchesSearch = !this.search || (
                    item.name.toLowerCase().includes(searchTerm) ||
                    item.labels.some(label => label.toLowerCase().includes(searchTerm))
                );

                // Date filter
                const matchesDate = this.passesDateFilter(item.date);

                // Label filter
                const matchesLabel = !this.filterString || item.labels.includes(this.filterString);

                return matchesSearch && matchesDate;
            }

            matchesTimelineFilter(item) {
                const searchTerm = this.search?.toLowerCase();

                // Text search
                const matchesSearch = !this.search || (
                    item.file.toLowerCase().includes(searchTerm) ||
                    item.labels.some(label => label.toLowerCase().includes(searchTerm))
                );

                // Label filter
                const matchesLabel = !this.filterString || item.labels.includes(this.filterString);

                return matchesSearch && matchesLabel;
            }

            createGauge({ value = 75, max = 100, label = '', size = 150, color = '#21ba45' }) {
                // Create container
                const container = document.createElement('div');
                container.className = 'gauge-container';
                container.style.display = 'inline-block';
                container.style.textAlign = 'center';

                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                const radius = size / 2;
                const lineWidth = 12;
                const center = size / 2;

                // Clear
                ctx.clearRect(0, 0, size, size);

                // Background arc (full circle)
                ctx.beginPath();
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = '#333'; // background track
                ctx.arc(center, center, radius - lineWidth, Math.PI, 0);
                ctx.stroke();

                // Foreground arc (value)
                const angle = Math.PI * (value / max);
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.arc(center, center, radius - lineWidth, Math.PI, Math.PI + angle, false);
                ctx.stroke();

                // Text
                const textDiv = document.createElement('h2');
                textDiv.className = 'ui header'
                textDiv.style.marginTop = '-60px';


                textDiv.innerHTML = `
        <strong>${label}</strong><br/>
        ${value}/${max} (${((value / max) * 100).toFixed(0)}%)
    `;
                container.appendChild(textDiv);

                return container;
            }

            createStatColumn(stat) {
                const percentage = (stat?.value / stat?.total) * 100;
                const isDown = percentage <= 50;

                // Outer column
                const column = document.createElement('div');
                column.className = 'column five wide';

                // Inverted Segment
                const segment = document.createElement('div');
                segment.className = `ui ${stat.color} attached bottom segment  center aligned`;

                // Header / Label
                const labelHeader = document.createElement('h4');
                labelHeader.className = `ui  attached top header `;

                labelHeader.textContent = stat.label;

                // Value with arrow and percent
                const valueText = document.createElement('div');
                valueText.className = 'ui small  sub header';
                valueText.innerHTML = `
        <small><i class="arrow ${isDown ? 'down' : 'up'} icon"></i></small>
    `;

                // Gauge
                const gauge = this.createGauge({
                    value: stat.value,
                    max: stat.total,
                    label: '', // Label already above
                    size: 120,
                    color: stat.color === 'red' ? '#db2828' :
                        stat.color === 'green' ? '#21ba45' :
                            stat.color === 'orange' ? '#f2711c' :
                                '#767676'
                });

                // Assemble
                column.appendChild(labelHeader);
                segment.appendChild(gauge);
                segment.appendChild(valueText);

                column.appendChild(segment);
                return column;
            }

            searchThisValue(value) {

                alert(value)
            }

            createPredictionGrid(predictedClassCounts) {
                // Outer wrapper <div>
                const wrapper = document.createElement('div');

                // Optional inner wrapper (can be removed if unnecessary)
                const inner = document.createElement('div');
                wrapper.appendChild(inner);

                // Grid container
                const grid = document.createElement('div');
                grid.className = 'ui three column grid';
                inner.appendChild(grid);

                // Loop through predictedClassCounts entries
                Object.entries(predictedClassCounts).forEach(([key, val]) => {
                    // Column
                    const column = document.createElement('div');
                    column.className = 'column';

                    // Segment
                    const segment = document.createElement('div');
                    segment.className = 'ui segment fluid center aligned inverted red';

                    // Statistic block
                    const stat = document.createElement('div');
                    stat.className = 'ui statistic inverted';

                    // Value
                    const value = document.createElement('div');
                    value.className = 'value';
                    value.textContent = val;

                    // Label
                    const label = document.createElement('div');
                    label.className = 'label';
                    label.textContent = `Predicted: ${key}`;

                    // Assemble
                    stat.appendChild(value);
                    stat.appendChild(label);
                    segment.appendChild(stat);
                    column.appendChild(segment);
                    grid.appendChild(column);
                });

                return wrapper;
            }

            renderStatsAMain() {

                this.statsHtmlMainHeaderStats.innerHTML = '';
                this.statsHtmlMain.innerHTML = '';
                let totalPass = 0;
                let totalFail = 0;
                const predictedClassCounts = {};

                // Filtered items using reusable filter method
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });

                filteredItems.forEach(item => {
                    item.labels.forEach(label => {
                        if (label.startsWith("Job.Pass=")) {
                            totalPass += parseInt(label.split("=")[1]);
                        } else if (label.startsWith("Job.Fail=")) {
                            totalFail += parseInt(label.split("=")[1]);
                        } else if (label.includes("PredictedClass=")) {
                            const predClass = label.split("=")[1];
                            predictedClassCounts[predClass] = (predictedClassCounts[predClass] || 0) + 1;
                        }
                    });
                });

                const totalItems = totalPass + totalFail;

                const statHeaderData = document.createElement('div');
                statHeaderData.className = ' ui grid';
                const sRow = document.createElement('div');
                sRow.className = 'row'

                const stats = [
                    { total: totalItems, value: totalItems, label: "Total Items", color: 'teal' },
                    { total: totalItems, value: totalPass, label: "Total Passes", color: 'green' },
                    { total: totalItems, value: totalFail, label: "Total Fails", color: 'red' }
                ];

                stats.forEach(stat => {
                    sRow.appendChild(this.createStatColumn(stat));
                });

                statHeaderData.appendChild(sRow);

                this.statsHtmlMainHeaderStats.appendChild(statHeaderData);
                this.statsHtmlMain.appendChild(this.createPredictionGrid(predictedClassCounts));
            }

            checkAlerts(thresholdPercent = 5) {
                const errorRates = this.getErrorRateTrend();
                return Object.entries(errorRates)
                    .filter(([day, rate]) => rate > thresholdPercent)
                    .map(([day, rate]) => ({ day, rate }));
            }

            getPredictedClassDistribution() {
                const classCounts = {};
                // Filter items first
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });

                filteredItems.forEach(item => {
                    item.labels.forEach(label => {
                        if (label.includes("PredictedClass=")) {
                            const predClass = label.split("=")[1];
                            classCounts[predClass] = (classCounts[predClass] || 0) + 1;
                        }
                    });
                });

                return classCounts;
            }

            getPassFailByGroup() {
                const groupStats = {};
                // Filter items first
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });

                filteredItems.forEach(item => {
                    const group = item.groupKey;
                    if (!groupStats[group]) groupStats[group] = { pass: 0, fail: 0 };

                    item.labels.forEach(label => {
                        if (label.startsWith("Job.Pass=")) groupStats[group].pass += parseInt(label.split("=")[1]);
                        if (label.startsWith("Job.Fail=")) groupStats[group].fail += parseInt(label.split("=")[1]);
                    });
                });

                return groupStats;
            }

            getErrorRateTrend() {
                // returns an object: { '2025-06-04': 5, '2025-06-05': 2, ... }
                const trend = {};
                // Filter items first
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });

                filteredItems.forEach(item => {
                    const day = new Date(item.date).toISOString().split('T')[0];
                    if (!trend[day]) trend[day] = { pass: 0, fail: 0 };

                    item.labels.forEach(label => {
                        if (label.startsWith("Job.Pass=")) trend[day].pass += parseInt(label.split("=")[1]);
                        if (label.startsWith("Job.Fail=")) trend[day].fail += parseInt(label.split("=")[1]);
                    });
                });

                // Calculate error rate percentage per day
                const errorRateTrend = {};
                for (const day in trend) {
                    const { pass, fail } = trend[day];
                    const total = pass + fail;
                    errorRateTrend[day] = total > 0 ? (fail / total) * 100 : 0;
                }
                return errorRateTrend;
            }

            computeStatsData() {
                let totalPass = 0;
                let totalFail = 0;
                const predictedClassCounts = {};

                // Filter items
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });

                filteredItems.forEach(item => {
                    item.labels.forEach(label => {
                        if (label.startsWith("Job.Pass=")) {
                            totalPass += parseInt(label.split("=")[1]);
                        } else if (label.startsWith("Job.Fail=")) {
                            totalFail += parseInt(label.split("=")[1]);
                        } else if (label.includes("PredictedClass=")) {
                            const predClass = label.split("=")[1];
                            predictedClassCounts[predClass] = (predictedClassCounts[predClass] || 0) + 1;
                        }
                    });
                });

                const totalItems = totalPass + totalFail;

                // Additional insights
                const errorRateTrend = this.getErrorRateTrend();
                const alerts = this.checkAlerts(5);
                const passFailByGroup = this.getPassFailByGroup();

                return {
                    totalItems,
                    totalPass,
                    totalFail,
                    predictedClassCounts,
                    errorRateTrend,
                    alerts,
                    passFailByGroup
                };
            }

            renderStats() {
                let totalPass = 0;
                let totalFail = 0;
                const predictedClassCounts = {};

                // Filter items first
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });

                filteredItems.forEach(item => {

                    item.labels.forEach(label => {
                        if (label.startsWith("Job.Pass=")) {
                            totalPass += parseInt(label.split("=")[1]);
                        } else if (label.startsWith("Job.Fail=")) {
                            totalFail += parseInt(label.split("=")[1]);
                        } else if (label.includes("PredictedClass=")) {
                            const predClass = label.split("=")[1];
                            predictedClassCounts[predClass] = (predictedClassCounts[predClass] || 0) + 1;
                        }
                    });
                });

                const totalItems = totalPass + totalFail;

                // Get more insights
                const errorRateTrend = this.getErrorRateTrend();
                const alerts = this.checkAlerts(5); // Alert if error rate > 5%
                const passFailByGroup = this.getPassFailByGroup();

                // Format the error rate trend as a simple list or stats
                const errorRateHtml = Object.entries(errorRateTrend).map(([day, rate]) => `
    <div class="column">
        <div class="ui segment center aligned red inverted">
                <div class="ui  statistic inverted">
      <div class="value">${rate.toFixed(0)}%</div>
      <div class="label">Errors on ${day}</div>
    </div>
    </div>
    </div>
  `).join("");

                // Format alerts (if any)
                const alertsHtml = alerts.length > 0 ? `
    <div class="ui red message">
      <strong>Alerts:</strong> High error rates detected on days:
      ${alerts.map(a => a.day).join(", ")}
    </div>
  ` : "";

                // Format pass/fail by groupKey summary (top 3)
                const groupsHtml = Object.entries(passFailByGroup)
                    .slice(0, 5)
                    .map(([group, counts]) => {
                        const totalGroup = counts.pass + counts.fail;
                        const failRate = totalGroup === 0 ? 0 : (counts.fail / totalGroup) * 100;
                        return `
                        <div class="column">
        <div class="ui segment center aligned inverted green">
      <div class="ui  statistic inverted">
        <div class="value">${failRate.toFixed(0)}%</div>
        <div class="label"> Part #:${group}</div>
      </div>
      </div>
      </div>`;
                    }).join("");

                // Predicted classes summary (top 3)
                const predictedHtml = Object.entries(predictedClassCounts)
                    .slice(0, 5)
                    .map(([cls, count]) => `
                    <div class="column">
        <div class="ui segment center aligned yellow inverted">
      <div class="ui  statistic inverted">
        <div class="value">${count}</div>
        <div class="label">Predicted: ${cls}</div>
      </div>
      </div>
      </div>
    `).join("");

                // Compose full HTML summary
                const statsHtml = `<div class="ui grid">
                    <div class="row">
                    ${this.makeStatSegment({ color: 'yellow', size: 'four', value: predictedHtml, label: "Top 5 Predicted Classes" })}
                    ${this.makeStatSegment({ color: 'red', size: 'four', value: errorRateHtml, label: "Error Rate Trend" })}
                    ${this.makeStatSegment({ color: 'green', size: 'four', value: groupsHtml, label: "Top 5 Fail Rate by Group", alert: alertsHtml })}
                    </div>
                    </div>`;

                this.statsHtml.innerHTML = statsHtml;
            }

            makeStatSegment(item) {
                return `
                <div class="column ${item.size} wide">
                    <h3 class="ui header attached top ">${item.label}</h3>
                     <div class=" ui segment inverted ${item.color} attached bottom  ">
                        <div class="ui one column grid">${item.value}</div>
                        <div class="ui one column grid">${item.alert ? item.alert : ''}</div>
                        </div>
                    </div>`
            }

            sortFilesByDate(files, recentFirst = true) {

                return files.sort((a, b) => {
                    const dateA = new Date(a.date);
                    const dateB = new Date(b.date);
                    return recentFirst ? dateB - dateA : dateA - dateB;
                });
            }

            imagePreviewDropdown() {
                const groupedFiles = {};
                this.summaryData = {};
                this.availableFilters.clear();

                for (const file of this.cachedFiles) {

                    // If there is a search query, filter the files based on it
                    if (this.search && !file.name.toLowerCase().includes(this.search.toLowerCase()) &&
                        !file.labels.some(label => label.toLowerCase().includes(this.search.toLowerCase()))) {
                        continue;  // Skip files that don't match the search
                    }

                    // Date filter check
                    if (!this.passesDateFilter(file.date)) continue;

                    // Other filters
                    if (this.filterString && !file.labels.includes(this.filterString)) continue;

                    // Trained toggle filter
                    if (!document.getElementById('showTrainedToggle')?.checked && this.saved.includes(file.name)) continue;

                    // Group the files by groupKey
                    if (!groupedFiles[file.groupKey]) groupedFiles[file.groupKey] = [];
                    groupedFiles[file.groupKey].push(file);

                    // Track labels for summary and available filters
                    for (const label of file.labels) {
                        this.summaryData[label] = (this.summaryData[label] || 0) + 1;
                        this.availableFilters.add(label);
                    }
                }

                // Sort files within each group by date (recent to oldest) if sorting is enabled
                if (this.sortByRecent) {
                    for (const key in groupedFiles) {
                        groupedFiles[key] = this.sortFilesByDate(groupedFiles[key], true);
                    }
                }
                return groupedFiles;
            }

            clearData() {
                this.timeSeriesData = [];
                this.summaryData = {};
                this.searchTheseNames = [];
                this.progressBar = 0;
                this.dates = [];
                this.groupKey = [];
                this.arryInfo = null;
                this.timeSeriesData = [];

            }

            async filterAndRenderFiles() {
                this.showLoader();

                clearInterval(this.autoReloadInterval);
                this.autoReloadInterval = null;
                console.log("Auto-reload stopped.");

                this.clearData()
                // Render the filtered files and charts
                this.cachedFiles = await this.queryRecentFilesByDirHandle().then(res => res.results).catch(e => console.warn(e))
                await this.loadTimeSeriesData();
                await this.loadGroupKeyData();
                await this.loadAvailableFiltersData();
                const groupedFiles = this.imagePreviewDropdown()
                this.renderGroupedFiles(groupedFiles);
                this.renderSummaryChart();
                this.renderFilterDropdown();
                this.renderTimelineChart();
                this.renderHeartbeatChart();
                this.renderCumulativeCountChart();
                this.renderStats();
                this.renderStatsAMain();
                this.renderSummary();
                this.getHealthIndicator();
                await this.renderCardGrid();
                this.setupCalendarDates();
                this.renderTrendVisualizer();
                this.insertGroupedDates();
                this.search = null;
                this.searchNumDropdown();
                this.hideLoader();
                this.toggleAutoReload();

            }

            renderTrendVisualizer() {
                const filtered = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) })
                this.trendVisualizer = new TrendVisualizer('trend-container', filtered);
                this.trendVisualizerCards = new TrendVisualizerCards('trend-container-card', filtered, this.animatedCounter, this.updateSearch);
            }

            toggleView() {
                if (this.viewToggle.checked) {
                    this.chartView.style.display = 'block';
                    this.imageView.style.display = 'none';
                } else {
                    this.chartView.style.display = 'none';
                    this.imageView.style.display = 'flex';
                }
            }

            toggleAutoReload() {

                if (!this.autoReloadInterval) {
                    this.autoReloadInterval = setInterval(() => {
                        if (this.dirHandle) {
                            this.updatedCache = true;
                            this.backgroundReloadCache();
                        }
                    }, 30000);
                } else {
                    clearInterval(this.autoReloadInterval);
                    this.autoReloadInterval = null;
                    console.log("Auto-reload stopped.");
                }
            }

            setupDateDropdown() {
                $('#dateFilterDropdown').dropdown({
                    onChange: (value) => {
                        this.dateFilter = value;
                        this.filterAndRenderFiles();
                    }
                });
            }

            setupCalendarDates() {

                /*  $('#rangestart').calendar({
                     type: 'date',
                      eventDates: this.dates.map(str => ({
                         date: new Date(str.date),
                         class: 'red',
                         message: str.message
                     })),
     
                     enabledDates:this.dates.map(str => ({
                         date: new Date(str.date)}))
                 }); */



            }

            showNewLabel(data) {
                const id = "newLabel"
                if (data.live) {
                    document.getElementById(id)?.remove();
                    const label = document.createElement('div');
                    label.id = id
                    label.innerHTML = `<a class="ui teal circular label right floating top ">${Math.ceil(data.count / 2)}</a>`;
                    document.getElementById('iconLabelDash').append(label);
                } else {
                    document.getElementById(id).remove();
                }
            }

            setupCalendar() {

                $('#rangestart').calendar({
                    type: 'date',
                    endCalendar: $('#rangeend'),

                    onChange: (date) => {
                        const bool = (date && this.dirHandle !== null || this.dirSelectedHandle !== null);
                        if (bool) {
                            this.rangestart = new Date(date.setHours(0, 0, 0, 0));
                            this.calStart = new Date(date.setHours(0, 0, 0, 0));
                        };
                    },


                });
                $('#rangeend').calendar({
                    type: 'date',
                    startCalendar: $('#rangestart'),
                    onChange: (date) => {
                        const bool = (date && this.dirHandle !== null || this.dirSelectedHandle !== null);
                        if (bool) {
                            this.rangeend = new Date(date.setHours(0, 0, 0, 0));
                            this.calEnd = new Date(date.setHours(11, 59, 59, 999));
                        };

                        this.filterAndRenderFiles();
                        this.searchNumDropdown();
                    }
                });

            }

            showLoader() {
                document.getElementById('globalLoader')?.style.setProperty('display', 'block');
            }

            hideLoader() {
                document.getElementById('globalLoader')?.style.setProperty('display', 'none');
            }


            //////////////////////////////////// DB Functions ////////////////////////////////////////////////

            openDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('AssureVision-db', 1);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('files')) {
                            const store = db.createObjectStore('files', { keyPath: 'name' });
                            store.createIndex('date', 'date');
                            store.createIndex('groupKey', 'groupKey');
                            store.createIndex('sortValue', 'sortValue');
                            store.createIndex('labels', 'labels', { multiEntry: true });
                            store.createIndex('content', 'content');
                            store.createIndex('imageBlob', 'imageBlob');
                            store.createIndex('dirHandle', 'dirHandle');
                        }
                    };
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            async queryRecentFilesByDirHandleNew(dirHandle, options = {}) {
                const {
                    startAfter = null, // Pass the key to start after
                    batchSize = 5000     // Number of items per batch
                } = options;

                const db = await this.openDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readonly');
                    const store = tx.objectStore('files');
                    const dateIndex = store.index('date');

                    // Calculate the date range
                    const now = new Date();
                    const pastTime = new Date();
                    pastTime.setDate(now.getDate() - 7);

                    const lowerBound = pastTime.toISOString();
                    const upperBound = now.toISOString();

                    let keyRange;

                    if (this.calStart === null) {
                        keyRange = IDBKeyRange.bound(lowerBound, upperBound);
                    } else {
                        const upper = new Date(this.calStart).toISOString();
                        const lower = new Date(this.calEnd).toISOString();
                        const [min, max] = upper < lower ? [upper, lower] : [lower, upper];
                        keyRange = min === max ? IDBKeyRange.only(min) : IDBKeyRange.bound(min, max);
                    }

                    const direction = 'next';
                    const request = dateIndex.openCursor(keyRange, direction);

                    const results = [];
                    let skipping = !!startAfter;
                    let count = 0;

                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (!cursor) {
                            return resolve({ results, nextStartAfter: null });
                        }

                        if (skipping) {
                            if (cursor.key <= startAfter) {
                                cursor.continue();
                                return;
                            } else {
                                skipping = false;
                            }
                        }

                        const item = cursor.value;
                        if (item.dirHandle === this.dirSelectedHandle) {
                            results.push(item);
                            count++;
                        }

                        if (count >= batchSize) {
                            // Return batch and next key to continue from
                            return resolve({ results, nextStartAfter: cursor.key });
                        }

                        cursor.continue();
                    };

                    request.onerror = (event) => reject(event.target.error);
                });
            }


            async queryRecentFilesByDirHandle(dirHandle) {
                const db = await this.openDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readonly');
                    const store = tx.objectStore('files');
                    const dateIndex = store.index('date');

                    // Calculate the date range
                    const now = new Date();
                    const pastTime = new Date();
                    pastTime.setDate(now.getDate() - 15);

                    // Convert dates to strings if you're storing them as ISO strings (e.g. '2025-08-13')
                    const lowerBound = pastTime.toISOString(); // 'YYYY-MM-DD'
                    const upperBound = now.toISOString();

                    let keyRange = null;

                    if (this.calStart === null) {
                        keyRange = IDBKeyRange.bound(lowerBound, upperBound);
                    } else {

                        const upper = new Date(this.calStart).toISOString();
                        const lower = new Date(this.calEnd).toISOString();
                        const [min, max] = upper < lower ? [upper, lower] : [lower, upper];

                        keyRange = min === max
                            ? IDBKeyRange.only(min)
                            : IDBKeyRange.bound(min, max);
                    }

                    const request = dateIndex.openCursor(keyRange);
                    const results = [];

                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            const item = cursor.value;
                            if (item.dirHandle === this.dirSelectedHandle) {
                                results.push(item);
                            }
                            cursor.continue();
                        } else {
                            resolve({ results: results });
                        }
                    };

                    request.onerror = (event) => reject(event.target.error);
                });
            }

            async loadAllCachedFiles() {
                const db = await this.openDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readonly');
                    const store = tx.objectStore('files');
                    const request = store.getAll();

                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            async saveFileToDB(fileMeta) {
                const db = await this.openDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readwrite');
                    const store = tx.objectStore('files');
                    const request = store.put(fileMeta);

                    request.onsuccess = () => resolve(true);
                    request.onerror = (e) => reject(e.target.error);
                });
            }

            async isFileInDB(name) {
                const db = await this.openDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readonly');
                    const store = tx.objectStore('files');
                    const request = store.get(name);

                    request.onsuccess = (event) => {
                        resolve(event.target.result);  // will be `undefined` if not found
                    };
                    request.onerror = (event) => {
                        reject(event.target.error);
                    };
                });
            }

            async getImageBlob(name) {
                const db = await this.openDB();

                return new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readonly');
                    const store = tx.objectStore('files');
                    const request = store.get(name);

                    request.onsuccess = () => {
                        const result = request.result;

                        if (!result || !result.imageBlob) {
                            resolve(undefined);
                            return;
                        }

                        resolve(result.imageBlob); // This is your Blob
                    };

                    request.onerror = (e) => reject(e.target.error);
                });
            }

            async clearDB() {
                const db = await this.openDB();
                const tx = db.transaction('files', 'readwrite');
                await tx.objectStore('files').clear();
                await tx.complete;
            }

            async updateImageBlob(name, newBlob) {
                const db = await this.openDB();

                return new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readwrite');
                    const store = tx.objectStore('files');

                    const getRequest = store.put(name);

                    getRequest.onsuccess = () => {
                        const data = getRequest.result;

                        if (!data) {
                            reject(new Error('Record not found'));
                            return;
                        }

                        data.imageBlob = newBlob;

                        const updateRequest = store.put(data);

                        updateRequest.onsuccess = () => resolve(true);
                        updateRequest.onerror = (e) => reject(e.target.error);
                    };

                    getRequest.onerror = (e) => reject(e.target.error);
                });
            }

            async getAllFileNames() {
                const db = await this.openDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readonly');
                    const store = tx.objectStore('files');
                    const request = store.getAllKeys();

                    request.onsuccess = () => resolve(new Set(request.result));  // Set for fast lookup
                    request.onerror = (e) => reject(e.target.error);
                });
            }

            async getAllFileNamesByKey() {
                const db = await this.openDB();
                const tx = db.transaction('files', 'readonly');
                const store = tx.objectStore('files');
                const index = store.index('dirHandle');

                const request = index.getAllKeys(this.dirSelectedHandle); // ✅ This gets primary keys only

                return await new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(new Set(request.result)); // returns Set of file names
                    request.onerror = (e) => reject(e.target.error);
                });
            }



            async readFolderContents() {

                clearInterval(this.autoReloadInterval);
                this.autoReloadInterval = null;
                console.log("Auto-reload stopped.");

                this.showLoader();
                this.timeSeriesData = [];
                if (!this.dirHandle) return;


                this.imageList.innerHTML = '';
                this.summaryData = {};
                this.availableFilters.clear();
                this.cachedFiles = [];

                const groupedFiles = {};
                const now = new Date();
                const showTrained = document.getElementById('showTrainedToggle')?.checked;

                const fileHandles = [];

                const files = await this.getAllFilesAndFolders(this.dirHandle, true);
                // Scan all .svg files and filter by cache
                const existingFileNames = await this.getAllFileNames();

                for await (const entry of files) {
                    const { svgHandle } = entry
                    if (svgHandle.kind === 'file' && svgHandle.name.endsWith('.svg')) {
                        if (!existingFileNames.has(svgHandle.name)) {

                            fileHandles.push(entry);
                        } else {
                            const cached = await this.isFileInDB(svgHandle.name);
                            const group = groupedFiles[cached.groupKey] ||= [];
                            group.push(cached);
                        }
                    }

                }


                const concurrency = 300;
                const initialRenderCount = 1000;

                const firstBatch = fileHandles.slice(0, initialRenderCount);
                for (let i = 0; i < firstBatch.length; i += concurrency) {
                    const batch = firstBatch.slice(i, i + concurrency);

                    await this.processBatch(batch, groupedFiles, now, showTrained);

                    const progress = Math.min(100, Math.round((i + concurrency) / fileHandles.length * 100));
                    $('#progressBar').progress({
                        percent: progress,
                        total: `${progress}%`
                    });
                }

                this.renderGroupedFiles(groupedFiles);
                this.filterAndRenderFiles();
                this.setupCalendarDates();

                const remainingHandles = fileHandles.slice(initialRenderCount);

                const backgroundProcess = async (startIdx) => {
                    if (startIdx >= remainingHandles.length) {
                        this.filterAndRenderFiles();
                        return;
                    }

                    const batch = remainingHandles.slice(startIdx, startIdx + concurrency);
                    await this.processBatch(batch, groupedFiles, now, showTrained);

                    const progress = Math.min(100, Math.round((initialRenderCount + startIdx + concurrency) / fileHandles.length * 100));
                    $('#toast-progress').progress('set percent', progress);

                    setTimeout(() => backgroundProcess(startIdx + concurrency), 10);
                };

                setTimeout(() => backgroundProcess(0), 0);

            }

            async processSvgFile(svgHandle, txtHandle, fullPath, groupedFiles, now, showTrained) {
                const svgName = svgHandle.name;

                if (!txtHandle) {
                    //  console.warn(`Missing TXT file for: ${svgName}`);
                    return null;
                }

                try {
                    const [svgFile, txtFile] = await Promise.all([
                        svgHandle.getFile(),
                        txtHandle.getFile()
                    ]);

                    const fileDate = new Date(svgFile.lastModified);
                    if (!this.passesDateFilter(fileDate)) return;

                    this.dates.push({
                        date: fileDate.toLocaleDateString(),
                        message: `Captured PN: ${svgName.split('_')[0]}`,
                    });

                    const txtContent = await txtFile.text();
                    const kvPairs = txtContent.split(',').map(e => {
                        const [k, v] = e.split(':').map(x => x.trim());
                        return { key: k, value: v };
                    });

                    if (this.filterString && !kvPairs.some(({ key, value }) => `${key}=${value}` === this.filterString)) {
                        return;
                    }

                    if (!showTrained && this.saved.includes(svgName)) return;

                    const keySet = new Set();
                    for (const { key } of kvPairs) {
                        if (keySet.has(key)) return;
                        keySet.add(key);
                    }

                    const parts = svgName.split('_');
                    const groupKey = parts[0];
                    const sortVal = parseInt(parts[2].replace('.svg', ''));

                    if (!groupedFiles[groupKey]) groupedFiles[groupKey] = [];
                    groupedFiles[groupKey].push({ name: svgName, sortValue: sortVal, content: txtContent });

                    if (!this.groupKey.includes(groupKey)) {
                        this.groupKey.push(groupKey);
                    }

                    for (const { key, value } of kvPairs) {
                        if (!key || !value) continue;
                        const label = `${key}=${value}`;
                        this.summaryData[label] = (this.summaryData[label] || 0) + 1;
                        this.availableFilters.add(label);
                    }

                    this.timeSeriesData.push({
                        timestamp: fileDate.toISOString(),
                        file: svgName,
                        label: svgName.replace('.svg', ''),
                        labels: kvPairs.map(({ key, value }) => `${key}=${value}`)
                    });

                    const dirPath = fullPath.includes('/')
                        ? fullPath.substring(0, fullPath.lastIndexOf('/'))
                        : fullPath;

                    console.log('processSvg : ', dirPath)
                    return {
                        name: svgName,
                        groupKey,
                        sortValue: sortVal,
                        content: txtContent,
                        date: fileDate.toISOString(),
                        labels: kvPairs.map(({ key, value }) => `${key}=${value}`),
                        dirHandle: dirPath
                    };

                } catch (e) {
                    console.warn(`Skipping ${svgName}: ${e.message}`);
                    return null;
                }
            }

            async processSvgFileOld(svgName, groupedFiles, now, showTrained) {
                const txtName = svgName.replace('.svg', '.txt');

                try {
                    const [svgHandle, txtHandle] = await Promise.all([
                        this.dirHandle.getFileHandle(svgName),
                        this.dirHandle.getFileHandle(txtName)
                    ]);

                    const [svgFile, txtFile] = await Promise.all([
                        svgHandle.getFile(),
                        txtHandle.getFile()
                    ]);

                    const fileDate = new Date(svgFile.lastModified);
                    if (!this.passesDateFilter(fileDate)) return;


                    this.dates.push({
                        date: fileDate.toLocaleDateString(),
                        message: `Captured PN: ${svgName.split('_')[0]}`,
                    });

                    const txtContent = await txtFile.text();
                    const kvPairs = txtContent.split(',').map(e => {
                        const [k, v] = e.split(':').map(x => x.trim());
                        return { key: k, value: v };
                    });

                    // Apply filter only once on parsed data
                    if (this.filterString && !kvPairs.some(({ key, value }) => `${key}=${value}` === this.filterString)) {
                        return;
                    }

                    if (!showTrained && this.saved.includes(svgName)) return;

                    // Avoid duplicate keys
                    const keySet = new Set();
                    for (const { key } of kvPairs) {
                        if (keySet.has(key)) return;
                        keySet.add(key);
                    }

                    // Add to grouped files
                    const parts = svgName.split('_');
                    const groupKey = parts[0];
                    const sortVal = parseInt(parts[2].replace('.svg', ''));

                    if (!groupedFiles[groupKey]) groupedFiles[groupKey] = [];
                    groupedFiles[groupKey].push({ name: svgName, sortValue: sortVal, content: txtContent });
                    this.groupKey.some(item => item === groupKey) ? null : this.groupKey.push(groupKey);

                    // Update summary data and filters
                    for (const { key, value } of kvPairs) {
                        if (!key || !value) continue;
                        const label = `${key}=${value}`;
                        this.summaryData[label] = (this.summaryData[label] || 0) + 1;
                        this.availableFilters.add(label);
                    }

                    // Track for timeline chart
                    this.timeSeriesData.push({
                        timestamp: fileDate.toISOString(),
                        file: svgName,
                        label: svgName.replace('.svg', ''),
                        labels: kvPairs.map(({ key, value }) => `${key}=${value}`)
                    });

                    return {
                        name: svgName,
                        groupKey,
                        sortValue: sortVal,
                        content: txtContent,
                        date: fileDate.toISOString(),
                        labels: kvPairs.map(({ key, value }) => `${key}=${value}`),
                        dirHandle: this.dirHandle.name
                    };

                } catch (e) {
                    // Optionally log or handle the error
                    // console.warn(`Skipping ${svgName}: ${e.message}`);
                    return null;
                }
            }

            async getAllFilesAndFolders2(dirHandle, recursive = true, path = '') {
                const files = [];

                for await (const [name, handle] of dirHandle.entries()) {
                    const currentPath = `${path}${name}`;

                    if (handle.kind === 'directory') {
                        if (recursive) {
                            const sub = await this.getAllFilesAndFolders(handle, true, `${currentPath}/`);
                            files.push(...sub);
                        }
                        continue;
                    }

                    if (handle.kind === 'file' && name.toLowerCase().endsWith('.svg')) {
                        const txtName = name.replace(/\.svg$/i, '.txt');

                        let txtHandle = null;
                        try {
                            txtHandle = await dirHandle.getFileHandle(txtName);
                        } catch (e) {
                            if (e.name !== 'NotFoundError') {
                                console.error(`Error accessing ${txtName}:`, e);
                            }
                        }

                        files.push({
                            svgHandle: handle,
                            txtHandle,
                            path: currentPath
                        });
                    }
                }

                return files;
            }

            async getAllFilesAndFolders(dirHandle, recursive = true, path = '') {
    const files = [];

    for await (const [name, handle] of dirHandle.entries()) {
        const currentPath = `${path}${name}`;

        if (handle.kind === 'directory') {
            if (recursive) {
                const sub = await this.getAllFilesAndFolders(handle, true, `${currentPath}/`);
                files.push(...sub);
            }
            continue;
        }

        if (handle.kind === 'file' && name.toLowerCase().endsWith('.svg')) {
            // If recursive is false, apply time filter
            if (!recursive) {
                const file = await handle.getFile();
                const isRecent = Date.now() - file.lastModified < 60_000;

                if (!isRecent) continue; // ⛔️ Skip old files
            }

            const txtName = name.replace(/\.svg$/i, '.txt');

            let txtHandle = null;
            try {
                txtHandle = await dirHandle.getFileHandle(txtName);
            } catch (e) {
                if (e.name !== 'NotFoundError') {
                    console.warn(`Error accessing ${txtName}:`, e);
                }
            }

            const filePath = recursive ? currentPath : dirHandle.name;

            files.push({
                svgHandle: handle,
                txtHandle,
                path: filePath
            });
        }
    }

    return files;
}

            async getAllFilesAndFolders1(dirHandle, recursive = true, path = '') {
                const files = [];

                for await (const [name, handle] of dirHandle.entries()) {
                    const currentPath = `${path}${name}`;

                    if (handle.kind === 'directory') {
                        if (recursive) {
                            const sub = await this.getAllFilesAndFolders(handle, true, `${currentPath}/`);
                            files.push(...sub);
                        }
                        continue;
                    }

                    if (handle.kind === 'file' && name.toLowerCase().endsWith('.svg')) {
                        const txtName = name.replace(/\.svg$/i, '.txt');

                        let txtHandle = null;
                        try {
                            txtHandle = await dirHandle.getFileHandle(txtName);
                        } catch (e) {
                            if (e.name !== 'NotFoundError') {
                                console.warn(`Error accessing ${txtName}:`, e);
                            }
                        }

                        // 👇 This is the fix
                        const filePath = recursive ? currentPath : dirHandle.name;

                        files.push({
                            svgHandle: handle,
                            txtHandle,
                            path: filePath
                        });
                    }
                }

                return files;
            }


            async getAllFilesAndFoldersOld(dirHandle, path = '') {
                const files = [];

                for await (const [name, handle] of dirHandle.entries()) {
                    const currentPath = `${path}${name}`;

                    if (handle.kind === 'directory') {
                        const sub = await this.getAllFilesAndFolders(handle, `${currentPath}/`);
                        files.push(...sub);
                    } else if (handle.kind === 'file' && name.endsWith('.svg')) {
                        // Try to find the matching .txt file in the same directory
                        const txtName = name.replace('.svg', '.txt');

                        let txtHandle = null;
                        try {
                            txtHandle = await dirHandle.getFileHandle(txtName);
                        } catch (e) {
                            // File not found — leave txtHandle as null
                        }

                        files.push({
                            svgHandle: handle,
                            txtHandle,
                            path: currentPath
                        });
                    }
                }

                return files;
            }

            processBatch = async (batch, groupedFiles, now, showTrained) => {
                const results = await Promise.all(
                    batch.map(async ({ svgHandle, txtHandle, path }) => {
                        if (txtHandle === null) return;
                        const result = await this.processSvgFile(svgHandle, txtHandle, path, groupedFiles, now, showTrained);
                        //const result = await this.processSvgFile(entry.name, groupedFiles, now, showTrained);
                        if (result) {
                            // Cache in IndexedDB
                            await this.saveFileToDB(result);
                        }

                        return result;
                    })
                );

                // ✅ Only add matching dir handles to in-memory cachedFiles
                const matchingResults = results.filter(item =>
                    item && item.dirHandle === this.dirSelectedHandle
                );
                this.cachedFiles.push(...matchingResults);
                return matchingResults.length;
            };



            /////////////////////////////////////////////////////////////////////////////////////////////////

            updateState(response) {
                this.cachedFiles.push(...response.results);
                this.state.nextStartAfter = response.nextStartAfter;
                this.state.hasMore = !!response.nextStartAfter;
            }

            async loadMore(dirHandle) {
                const loadMoreBtn = document.getElementById("loadMoreBtn");

                // Disable the button immediately to prevent multiple clicks
                loadMoreBtn.disabled = true;

                // Exit early if no more results to load
                if (!this.state.hasMore) {
                    loadMoreBtn.style.display = 'none';
                    this.filterAndRenderFiles();
                    return;
                } else {
                    loadMoreBtn.style.display = 'block';
                    this.filterAndRenderFiles();
                    return;
                }

                // Fetch the next batch
                const response = await this.queryRecentFilesByDirHandle(dirHandle, {
                    startAfter: this.state.nextStartAfter,
                    batchSize: 10
                });

                // Append the results and update state
                this.cachedFiles.push(...response.results);
                this.state.nextStartAfter = response.nextStartAfter;
                this.state.hasMore = !!response.nextStartAfter;

                // Hide or re-enable button based on whether more data exists
                if (!this.state.hasMore) {
                    loadMoreBtn.style.display = 'none';
                } else {
                    loadMoreBtn.disabled = false;
                    this.filterAndRenderFiles();
                }
            }



            async loadTimeSeriesData() {
                // Track for timeline chart
                const tSData = await this.queryRecentFilesByDirHandle();
                tSData.results.forEach(file => {
                    this.timeSeriesData.push({
                        timestamp: file.date,
                        file: file.name,
                        label: file.name.replace('.svg', ''),
                        labels: file.labels
                    });
                });
            }

            async loadGroupKeyData() {
                // Track for timeline chart
                const gKData = await this.queryRecentFilesByDirHandle();
                gKData.results.forEach(file => {
                    this.groupKey.some(item => item === file.groupKey) ?
                        null : this.groupKey.push(file.groupKey);
                });
            }

            async loadAvailableFiltersData() {
                // Track for timeline chart
                const aFData = await this.queryRecentFilesByDirHandle();
                aFData.results.forEach(file => {
                    this.availableFilters.add(file.label);
                });
            }

            passesDateFilter(fileDate) {
                //const now = new Date();
                let result = true;

                const fileDateObj = new Date(fileDate);
                const startDateObj = new Date(this.rangestart);
                const endDateObj = new Date(this.rangeend);

                // Normalize times to 00:00:00 to compare dates only
                fileDateObj.setHours(0, 0, 0, 0);
                startDateObj.setHours(0, 0, 0, 0);
                endDateObj.setHours(0, 0, 0, 0);

                return (fileDateObj >= startDateObj && fileDateObj <= endDateObj);

            }

            formatToCentralTime(isoString) {

                try {

                    const date = new Date(isoString);

                    const options = {
                        timeZone: 'America/Chicago',
                        year: '2-digit',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false,
                    };

                    const formatter = new Intl.DateTimeFormat('en-US', options);
                    const parts = formatter.formatToParts(date);

                    const getPart = type => parts.find(p => p.type === type)?.value || '00';

                    const formatted = `${getPart('month')}/${getPart('day')}/${getPart('year')}, ` +
                        `${getPart('hour')}:${getPart('minute')}:${getPart('second')}`;

                    const milliseconds = String(date.getMilliseconds()).padStart(3, '0');

                    return `${formatted}.${milliseconds}`;

                } catch (error) {

                    console.warn(error);

                }

            }

            extractFilesFromGroups(grouped) {
                const allFiles = [];

                for (const groupKey in grouped) {
                    const files = grouped[groupKey].sort((a, b) => a.sortValue - b.sortValue);
                    files.forEach(file => {
                        const labelParts = (file.content || '').split(',');
                        const labelText = labelParts[0]?.split(':')[1]?.trim() + '/' + (labelParts[1]?.split(':')[1]?.trim() || '');

                        allFiles.push({
                            name: file.name,
                            label: labelText || 'N/A',
                            group: groupKey,
                            content: file.content,
                            date: this.formatToCentralTime(file.date)
                        });
                    });
                }

                return allFiles;
            }

            renderGroupedFiles(groupedData, savedFiles = [], currentPage = 1) {
                const items = this.extractFilesFromGroups(groupedData);

                // Ensure ITEMS_PER_PAGE has a default if not already set
                this.ITEMS_PER_PAGE = this.ITEMS_PER_PAGE || 10;

                const totalPages = Math.ceil(items.length / this.ITEMS_PER_PAGE);
                currentPage = Math.max(1, Math.min(currentPage, totalPages));

                const start = (currentPage - 1) * this.ITEMS_PER_PAGE;
                const paginatedItems = items.slice(start, start + this.ITEMS_PER_PAGE);

                const tableBody = document.getElementById('paginated-table-body');
                tableBody.innerHTML = '';

                paginatedItems.forEach((file, index) => {
                    const row = document.createElement('tr');

                    const nameCell = document.createElement('td');
                    nameCell.textContent = file.name.split('_')[2];
                    nameCell.style.cursor = 'pointer';
                    row.onclick = () => { this.loadImage(file.name, file.content) };// Task use for modal

                    const labelCell = document.createElement('td');
                    labelCell.textContent = file.label;

                    const statusCell = document.createElement('td');
                    statusCell.innerHTML = file.content.includes('Job.Pass:1')
                        ? '<i class="ui icon check green"></i>'
                        : '<i class="ui icon times red"></i>';

                    const date = document.createElement('td');
                    date.textContent = file.date;

                    row.appendChild(date);
                    row.appendChild(nameCell);
                    row.appendChild(statusCell);
                    row.appendChild(labelCell);


                    tableBody.appendChild(row);
                });

                const paginationControls = document.getElementById('pagination-controls');
                paginationControls.innerHTML = '';

                // --- Dropdown: Items Per Page ---


                const dropdownWrapper = document.createElement('select');
                dropdownWrapper.className = 'ui dropdown selection button';
                [10, 20, 50, 100].forEach(value => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = `${value} per page`;
                    if (value === this.ITEMS_PER_PAGE) option.selected = true;
                    dropdownWrapper.appendChild(option);
                });

                dropdownWrapper.onchange = (e) => {
                    this.ITEMS_PER_PAGE = parseInt(e.target.value, 10);
                    this.renderGroupedFiles(groupedData, savedFiles, 1); // Reset to first page
                };

                paginationControls.appendChild(dropdownWrapper);

                // --- First Button ---
                const firstBtn = document.createElement('a');
                firstBtn.className = `icon item ${currentPage === 1 ? 'disabled' : ''}`;
                firstBtn.innerHTML = '<i class="angle double left icon"></i>';
                firstBtn.title = 'First page';
                firstBtn.onclick = () => {
                    if (currentPage > 1) this.renderGroupedFiles(groupedData, savedFiles, 1);
                };
                paginationControls.appendChild(firstBtn);

                // --- Previous Button ---
                const prevBtn = document.createElement('a');
                prevBtn.className = `icon item ${currentPage === 1 ? 'disabled' : ''}`;
                prevBtn.innerHTML = '<i class="chevron left icon"></i>';
                prevBtn.title = 'Previous page';
                prevBtn.onclick = () => {
                    if (currentPage > 1) this.renderGroupedFiles(groupedData, savedFiles, currentPage - 1);
                };
                paginationControls.appendChild(prevBtn);

                // --- Next Button ---
                const nextBtn = document.createElement('a');
                nextBtn.className = `icon item ${currentPage === totalPages ? 'disabled' : ''}`;
                nextBtn.innerHTML = '<i class="chevron right icon"></i>';
                nextBtn.title = 'Next page';
                nextBtn.onclick = () => {
                    if (currentPage < totalPages) this.renderGroupedFiles(groupedData, savedFiles, currentPage + 1);
                };
                paginationControls.appendChild(nextBtn);

                // --- Last Button ---
                const lastBtn = document.createElement('a');
                lastBtn.className = `icon item ${currentPage === totalPages ? 'disabled' : ''}`;
                lastBtn.innerHTML = '<i class="angle double right icon"></i>';
                lastBtn.title = 'Last page';
                lastBtn.onclick = () => {
                    if (currentPage < totalPages) this.renderGroupedFiles(groupedData, savedFiles, totalPages);
                };
                paginationControls.appendChild(lastBtn);
            }

            createNoImageMessage(file) {
                // Create the outer message div
                const messageDiv = document.createElement('div');
                messageDiv.className = 'ui icon message warning';

                // Create the icon element
                const icon = document.createElement('i');
                icon.className = 'file icon';
                messageDiv.appendChild(icon);

                // Create the content container
                const contentDiv = document.createElement('div');
                contentDiv.className = 'content';

                // Create the header
                const headerDiv = document.createElement('div');
                headerDiv.className = 'header';
                headerDiv.textContent = 'No image';
                contentDiv.appendChild(headerDiv);

                // Create the paragraph
                const paragraph = document.createElement('p');
                paragraph.innerHTML = `Select folder: <strong>${file.dirHandle}</strong>`;
                contentDiv.appendChild(paragraph);

                // Add content to the main message div
                messageDiv.appendChild(contentDiv);

                return messageDiv;
            }

            async loadImage(svgFilename, txtContent) {
                this.currentFilename = svgFilename;
                const dataTable = document.getElementById('dataTable');
                dataTable.innerHTML = '';

                const svgHandle = await this.dirHandle.getFileHandle(svgFilename);

                const svgFile = await svgHandle.getFile();
                const lastModified = new Date(svgFile.lastModified);

                const dateFormatted = lastModified.toLocaleDateString([], {
                    year: 'numeric', month: 'short', day: 'numeric'
                });
                const timeFormatted = lastModified.toLocaleTimeString([], {
                    hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true
                });

                document.querySelector('#imageView h4.ui.header').innerHTML =
                    `Preview : ${svgFilename.split('_')[0]} <div class="sub header">Captured ${dateFormatted} at ${timeFormatted}</div>`;

                txtContent.split(',').forEach(entry => {
                    const [key, value] = entry.split(':');
                    if (key && value) {
                        const row = document.createElement('tr');
                        row.innerHTML = `<td>${key.trim()}</td><td>${value.trim()}</td>`;
                        dataTable.appendChild(row);
                    }
                });

                const isSaved = this.saved.includes(svgFilename);
                this.saveBtn.textContent = isSaved ? 'Untrain' : 'Train';
                this.saveBtn.classList.toggle('red', isSaved);
                this.saveBtn.classList.toggle('green', !isSaved);

                const svgText = await svgFile.text();
                let finalSvg = svgText;


                const bmpMatch = finalSvg.match(/xlink:href=['"]([^'"]+\.bmp)['"]/i);
                if (bmpMatch && bmpMatch[1]) {
                    try {
                        const bmpHandle = await this.dirHandle.getFileHandle(bmpMatch[1]);
                        const bmpFile = await bmpHandle.getFile();
                        const bmpBuffer = await bmpFile.arrayBuffer();
                        const bmpBase64 = this.arrayBufferToBase64(bmpBuffer);
                        const dataUri = `data:image/bmp;base64,${bmpBase64}`;
                        finalSvg = finalSvg.replace(bmpMatch[0], `xlink:href="${dataUri}"`);
                        this.updateImageBlob(file.name, finalSvg);
                    } catch (err) {
                        console.warn(`⚠️ BMP not found: ${bmpMatch[1]}`, err);
                    }
                }


                const blob = new Blob([finalSvg], { type: 'image/svg+xml' });
                const svgUrl = URL.createObjectURL(blob);
                this.svgViewer.setAttribute('data', svgUrl);

                setTimeout(() => {
                    this.svgViewer.style.display = 'none';
                    this.svgViewer.offsetHeight;
                    this.svgViewer.style.display = 'block';
                }, 70);
            }

            async loadImageObs(file) {

                let blob = null, url = null;
                const imageDiv = document.createElement('div');
                imageDiv.className = 'image';
                imageDiv.style = `
        height: 200px;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #f9f9f9;
    `;

                let finalSvg = '';
                try {
                    const storedBlob = await this.getImageBlob(file.name);

                    if (!storedBlob) {
                        const svgHandle = await this.dirHandle.getFileHandle(file.name);
                        const svgFile = await svgHandle.getFile();
                        const svgText = await svgFile.text();
                        finalSvg = svgText;

                        // Embed BMP inside SVG if needed
                        const bmpMatch = finalSvg.match(/xlink:href=['"]([^'"]+\.bmp)['"]/i);
                        if (bmpMatch && bmpMatch[1]) {
                            try {
                                const bmpHandle = await this.dirHandle.getFileHandle(bmpMatch[1]);
                                const bmpFile = await bmpHandle.getFile();
                                const bmpBuffer = await bmpFile.arrayBuffer();
                                const bmpBase64 = this.arrayBufferToBase64(bmpBuffer);
                                const dataUri = `data:image/bmp;base64,${bmpBase64}`;
                                finalSvg = finalSvg.replace(bmpMatch[0], `xlink:href="${dataUri}"`);
                                this.updateImageBlob(file.name, finalSvg);

                            } catch (err) {
                                console.warn(`⚠️ BMP not found: ${bmpMatch[1]}`, err);
                            }
                        }
                        blob = new Blob([finalSvg], { type: 'image/svg+xml' });
                        url = URL.createObjectURL(blob);
                    } else {

                        blob = new Blob([storedBlob], { type: 'image/svg+xml' });
                        url = URL.createObjectURL(blob);
                    }


                    const img = document.createElement('img');
                    img.className = 'ui large image';
                    img.src = url;
                    img.alt = 'SVG image';
                    img.style = 'width: 100%; height: 100%; object-fit: cover;';

                    img.onload = () => {
                        URL.revokeObjectURL(url); // ✅ safe to revoke now
                    };

                    imageDiv.appendChild(img);

                } catch (err) {

                    // Fallback if SVG fails
                    const failMessage = this.createNoImageMessage(file);
                    imageDiv.appendChild(failMessage);
                }

                return imageDiv;
            }

            arrayBufferToBase64(buffer) {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                const len = bytes.length;
                for (let i = 0; i < len; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            async getFilteredFiles() {

                let data = await this.queryRecentFilesByDirHandle('FS');
                const filteredData = data.results.filter(file => {
                    if (!this.passesDateFilter(file.date)) return false;
                    if (this.filterString && !file.labels.includes(this.filterString)) return false;
                    // If there is a search query, filter the files based on it
                    if (this.search && !file.name.toLowerCase().includes(this.search.toLowerCase()) &&
                        !file.labels.some(label => label.toLowerCase().includes(this.search.toLowerCase()))) {
                        return false;  // Skip files that don't match the search
                    }
                    return true;
                });

                if (this.sortByRecent) {
                    return this.sortFilesByDate(filteredData, true);
                } else {
                    return this.sortFilesByDate(filteredData, false);;
                }
            }

            toggleSave() {
                if (!this.currentFilename) return alert('No file selected');
                const index = this.saved.indexOf(this.currentFilename);

                if (this.saveBtn.textContent === 'Train') {
                    if (index === -1) {
                        this.saved.push(this.currentFilename);
                        localStorage.setItem('savedFilenames', JSON.stringify(this.saved));
                        alert(`Saved: ${this.currentFilename}`);
                    }
                } else {
                    if (index !== -1) {
                        this.saved.splice(index, 1);
                        localStorage.setItem('savedFilenames', JSON.stringify(this.saved));
                        alert(`Untrained: ${this.currentFilename}`);
                    }
                }

                this.filterAndRenderFiles();
            }

            isWithinTimeWindow(fileDateIn) {
                const fileDate = new Date(fileDateIn);

                if (this.startTime) {
                    const start1 = new Date(this.startTime.start1);
                    const start2 = new Date(this.startTime.start2);
                    const startMax = new Date(Math.max(start1, start2));
                    if (fileDate <= startMax) return false;
                }

                if (this.endTime) {
                    const end1 = new Date(this.endTime.end1);
                    const end2 = new Date(this.endTime.end2);
                    const endMin = new Date(Math.min(end1, end2));
                    if (fileDate >= endMin) return false;
                }

                return true;
            }

            dateRangeFilter(fileDate) {
                const fileDateObj = new Date(fileDate);
                const startDateObj = new Date(this.rangestart);
                const endDateObj = new Date(this.rangeend);

                // Normalize times to 00:00:00 to compare dates only
                fileDateObj.setHours(0, 0, 0, 0);
                startDateObj.setHours(0, 0, 0, 0);
                endDateObj.setHours(0, 0, 0, 0);
                return (fileDateObj >= startDateObj && fileDateObj <= endDateObj);
            }

            renderTimelineChart() {
                const ctx = this.timelineChartCtx;

                if (this.timelineChartInstance) {
                    this.timelineChartInstance.destroy();
                }

                const filteredData = this.timeSeriesData.filter(entry => {
                    const fileDate = new Date(entry.timestamp); // Ensure it's a Date
                    if (!this.dateRangeFilter(fileDate)) return false;

                    if (!this.isWithinTimeWindow(fileDate)) return false;

                    if (!this.matchesTimelineFilter(entry)) return false;

                    return true;
                });

                const grouped = {};

                filteredData.forEach((entry) => {
                    const labelGroup = this.filterString || 'All';

                    if (!grouped[labelGroup]) grouped[labelGroup] = [];
                    grouped[labelGroup].push({
                        x: new Date(entry.timestamp).toISOString(), // time on X-axis
                        y: 1, // constant Y to align all events horizontally
                        label: entry.file
                    });
                });

                const datasets = Object.keys(grouped).map((group, i) => ({
                    label: group,
                    data: grouped[group],
                    pointBackgroundColor: `hsl(${(i * 60) % 360}, 70%, 50%)`,
                    pointRadius: 5
                }));

                this.timelineChartInstance = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets },
                    options: {
                        responsive: true,
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    tooltipFormat: 'PPpp'
                                },
                                title: { display: true, text: 'Timestamp' }
                            },
                            y: {
                                display: false // no need for Y-axis ticks if events are aligned
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        const point = context.raw;
                                        const date = new Date(point.x);
                                        const time = date.toLocaleTimeString();
                                        const day = date.toLocaleDateString();
                                        return `${point.label} - ${day} ${time}`;
                                    }
                                }
                            },
                            title: {
                                display: false,
                                text: 'Filtered Timeline (Time on X-axis)'
                            }
                        }
                    }
                });
            }

            renderSummaryChart() {
                const ctx = this.summaryChartCtx;
                const isStacked = this.stackToggle?.checked;

                const fieldValueCounts = {};

                Object.keys(this.summaryData).forEach(label => {
                    const [field, value] = label.split('=');
                    if (!field || !value) return;

                    if (!fieldValueCounts[field]) {
                        fieldValueCounts[field] = {};
                    }

                    fieldValueCounts[field][value] = (fieldValueCounts[field][value] || 0) + this.summaryData[label];
                });

                const allFields = Object.keys(fieldValueCounts);
                const allValues = Array.from(
                    new Set(
                        Object.values(fieldValueCounts)
                            .flatMap(obj => Object.keys(obj))
                    )
                ).sort();

                const datasets = allValues.map((val, index) => ({
                    label: val,
                    data: allFields.map(field => fieldValueCounts[field][val] || 0),
                    backgroundColor: `hsl(${(index * 60) % 360}, 70%, 60%)`
                }));

                if (this.chartInstance) {
                    this.chartInstance.destroy();
                }

                this.chartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: allFields,
                        datasets
                    },
                    options: {
                        plugins: {
                            title: {
                                display: false
                            }
                        },
                        responsive: true,
                        scales: {
                            x: {
                                stacked: isStacked, // ✅ stack on X axis
                                title: {
                                    display: true,
                                    text: 'Field'
                                }
                            },
                            y: {
                                stacked: isStacked, // ✅ stack on Y axis
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Count'
                                }
                            }
                        }
                    }
                });
            }

            renderCumulativeCountChart() {
                const ctx = this.cumulativeCountChartCtx;

                if (this.cumulativeCountChartInstance) {
                    this.cumulativeCountChartInstance.destroy();
                }

                const filteredData = this.timeSeriesData.filter(entry => {
                    const fileDate = new Date(entry.timestamp);
                    if (!this.dateRangeFilter(fileDate)) return false;
                    if (!this.isWithinTimeWindow(fileDate)) return false;
                    if (!this.matchesTimelineFilter(entry)) return false;

                    return true;
                });

                // Step 1: Group by prefix and sort entries by time
                const grouped = {};
                filteredData.forEach(entry => {
                    const prefix = entry.file.split('_')[0];
                    if (!grouped[prefix]) grouped[prefix] = [];

                    grouped[prefix].push({
                        timestamp: new Date(entry.timestamp).getTime(),
                        label: entry.file
                    });
                });

                // Step 2: Sort each group and compute cumulative counts
                const datasets = [];
                Object.keys(grouped).forEach((prefix, index) => {
                    const entries = grouped[prefix].sort((a, b) => a.timestamp - b.timestamp);
                    const cumulativeData = [];

                    let count = 0;
                    entries.forEach(entry => {
                        count += 1;
                        cumulativeData.push({
                            x: new Date(entry.timestamp).toISOString(),
                            y: count
                        });
                    });

                    datasets.push({
                        label: prefix,
                        data: cumulativeData,
                        borderColor: `hsl(${(index * 60) % 360}, 70%, 40%)`,
                        backgroundColor: `hsla(${(index * 60) % 360}, 70%, 40%, 0.2)`,
                        fill: false,
                        tension: 0.2,
                        pointRadius: 0,
                        showLine: true,

                    });
                });

                // Step 3: Render the chart
                this.cumulativeCountChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        /* animation: {
                            x: {
                                type: 'number',
                                easing: 'linear',
                                duration: 200,
                                from: NaN, // the point is initially skipped
                                delay(ctx) {
                                    if (ctx.type !== 'data' || ctx.xStarted) {
                                        return 0;
                                    }
                                    ctx.xStarted = true;
                                    return ctx.index * 70; // delay per point
                                }
                            },
                            y: {
                                type: 'number',
                                easing: 'linear',
                                duration: 200,
                                from: NaN,
                                delay(ctx) {
                                    if (ctx.type !== 'data' || ctx.yStarted) {
                                        return 0;
                                    }
                                    ctx.yStarted = true;
                                    return ctx.index * 70;
                                }
                            }
                        }, */
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    tooltipFormat: 'PPpp'
                                },
                                title: {
                                    display: true,
                                    text: 'Time'
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Cumulative Count'
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: context => {
                                        const point = context.raw;
                                        return `${context.dataset.label}: ${point.y} total as of ${new Date(point.x).toLocaleTimeString()}`;
                                    }
                                }
                            },
                            title: {
                                display: false,
                                text: 'Cumulative Count Over Time by Prefix'
                            },
                            legend: {
                                display: true
                            }
                        }
                    }
                });
            }

            renderHeartbeatChart() {
                const ctx = this.heartbeatChartCtx;

                if (this.heartbeatChartInstance) {
                    this.heartbeatChartInstance.destroy();
                }

                const filteredData = this.timeSeriesData.filter(entry => {
                    const fileDate = new Date(entry.timestamp);
                    if (!this.dateRangeFilter(fileDate)) return false;
                    if (!this.isWithinTimeWindow(fileDate)) return false;
                    if (!this.matchesTimelineFilter(entry)) return false;

                    return true;
                });

                // Step 1: Time bin and count pass/fail per prefix
                const timeBinSize = 60 * 1000; // 1 minute
                const groupedCounts = {}; // { prefix: { binnedTime: { pass: count, fail: count } } }

                filteredData.forEach(entry => {
                    const prefix = entry.file.split('_')[0];
                    const timestamp = new Date(entry.timestamp).getTime();
                    const binnedTime = new Date(Math.floor(timestamp / timeBinSize) * timeBinSize).toISOString();
                    const isPass = entry.labels.includes("Job.Pass=1");

                    if (!groupedCounts[prefix]) groupedCounts[prefix] = {};
                    if (!groupedCounts[prefix][binnedTime]) {
                        groupedCounts[prefix][binnedTime] = { pass: 0, fail: 0 };
                    }

                    if (isPass) {
                        groupedCounts[prefix][binnedTime].pass += 1;
                    } else {
                        groupedCounts[prefix][binnedTime].fail += 1;
                    }
                });

                // Step 2: Build datasets (1 for pass, 1 for fail per prefix)
                const datasets = [];
                const colors = ['green', 'red'];

                Object.keys(groupedCounts).forEach((prefix, index) => {
                    const timePoints = groupedCounts[prefix];

                    const passData = [];
                    const failData = [];

                    Object.keys(timePoints).forEach(time => {
                        passData.push({ x: time, y: timePoints[time].pass });
                        failData.push({ x: time, y: timePoints[time].fail });
                    });

                    passData.sort((a, b) => new Date(a.x) - new Date(b.x));
                    failData.sort((a, b) => new Date(a.x) - new Date(b.x));

                    datasets.push({
                        label: `${prefix} - Pass`,
                        data: passData,
                        borderColor: 'green',
                        backgroundColor: 'rgba(0, 128, 0, 0.4)',
                        fill: false,
                        tension: 0.1,
                        stack: prefix, // allow stacking pass/fail per prefix
                        pointRadius: 0.5,
                        showLine: true
                    });

                    datasets.push({
                        label: `${prefix} - Fail`,
                        data: failData,
                        borderColor: 'red',
                        backgroundColor: 'rgba(255, 0, 0, 0.4)',
                        fill: false,
                        tension: 0.1,
                        stack: prefix, // allow stacking pass/fail per prefix
                        pointRadius: 0.5,
                        showLine: true
                    });
                });

                // Step 3: Chart.js config
                this.heartbeatChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        /* animation: {
                            x: {
                                type: 'number',
                                easing: 'linear',
                                duration: 200,
                                from: NaN, // the point is initially skipped
                                delay(ctx) {
                                    if (ctx.type !== 'data' || ctx.xStarted) {
                                        return 0;
                                    }
                                    ctx.xStarted = true;
                                    return ctx.index * 70; // delay per point
                                }
                            },
                            y: {
                                type: 'number',
                                easing: 'linear',
                                duration: 200,
                                from: NaN,
                                delay(ctx) {
                                    if (ctx.type !== 'data' || ctx.yStarted) {
                                        return 0;
                                    }
                                    ctx.yStarted = true;
                                    return ctx.index * 70;
                                }
                            }
                        }, */
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    tooltipFormat: 'PPpp'
                                },
                                title: {
                                    display: true,
                                    text: 'Time'
                                }
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Job Count'
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: context => {
                                        const point = context.raw;
                                        return `${context.dataset.label}: ${point.y} at ${new Date(point.x).toLocaleTimeString()}`;
                                    }
                                }
                            },
                            title: {
                                display: false,
                                text: 'Job Count Over Time (Pass vs Fail, by Prefix)'
                            },
                            legend: {
                                display: true
                            }
                        }
                    }
                });
            }

            renderFilterDropdown() {
                const dropdown = $('#filterDropdown');
                const menu = dropdown.find('.menu');
                menu.empty();

                menu.append(`<div class="item" data-value="">All (${Object.values(this.summaryData).reduce((a, b) => a + b, 0)})</div>`);
                [...this.availableFilters].sort().forEach(filter => {
                    const count = this.summaryData[filter] || 0;
                    menu.append(`<div class="item" data-value="${filter}">${filter.split('=')[1]} (${count})</div>`);
                });

                dropdown.dropdown('refresh');
                dropdown.dropdown({
                    onChange: (value) => {
                        this.filterString = value;
                        this.filterAndRenderFiles();
                    }
                });
            }

            clearDate() {
                this.setCalendarDatesToDefault();
                $('#specificDateCalendar').calendar('clear');
                this.filterAndRenderFiles();


            }
        }

        const folderManager = new FolderManager();
        $('.menu.item.sidebar').tab();

        const driver = window.driver.js.driver;

        const tour = driver({
            showProgress: true,
            overlayColor: 'rgba(0,0,0,0.6)',        // dim overlay for focus
            overlayOpacity: 1,                    // partial transparency
            animate: true,                          // enable animated transitions
            nextBtnText: 'Next →',
            prevBtnText: '← Back',
            doneBtnText: 'Finish',
            steps: [
                {
                    element: '.ui.top.fixed.menu .item h3',
                    popover: {
                        title: 'App Title',
                        description: 'This shows your branding and app name.',
                        side: 'bottom',
                        align: 'start'
                    }
                },
                {
                    element: '#folderPicker',
                    popover: {
                        title: 'Folder Picker',
                        description: 'Use this button to select a folder.',
                        side: 'bottom',
                        align: 'start'
                    }
                },
                {
                    element: '#reloadBtn',
                    popover: {
                        title: ' Reload Folder',
                        description: 'Use this button to reload the current folder.',
                        side: 'bottom',
                        align: 'start'
                    }
                },
                {
                    element: '#searchQry',
                    popover: {
                        title: 'Search Box',
                        description: 'Type keywords to search through your data.',
                        side: 'bottom',
                        align: 'start'
                    }
                },
                {
                    element: '#rangestart',
                    popover: {
                        title: 'Start Date Filter',
                        description: 'Select the start of your date range.',
                        side: 'top',
                        align: 'start'
                    }
                },
                {
                    element: '#rangeend',
                    popover: {
                        title: 'End Date Filter',
                        description: 'Select the end of your date range.',
                        side: 'top',
                        align: 'start'
                    }
                },
                {
                    element: '.ui.left.sidebar .item[data-tab="dashboard-page"]',
                    popover: {
                        title: 'Sidebar Navigation',
                        description: 'Navigate between different pages here.',
                        side: 'right',
                        align: 'start'
                    }
                },
                {
                    element: '#timelineChart',
                    popover: {
                        title: 'Timeline Chart',
                        description: 'Visualize your data over time.',
                        side: 'top',
                        align: 'center'
                    }
                },
                {
                    popover: {
                        title: 'All Set!',
                        description: "That's a quick tour of your app. Explore further!",
                        side: 'center',
                        align: 'center'
                    }
                }
            ]
        });

        document.getElementById('startTourBtn').addEventListener('click', () => {
            tour.drive();
        });
    </script>

</body>

</html>