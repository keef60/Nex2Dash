<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>AssureVision</title>

    <!-- jQuery (required by Semantic UI JavaScript) -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

    <!-- ✅ Fomantic UI CSS and JS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fomantic-ui/2.9.4/semantic.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fomantic-ui/2.9.4/semantic.min.js"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <!-- Driver.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/driver.js@latest/dist/driver.js.iife.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/driver.js@latest/dist/driver.css" />

    <style>
        .extra.content canvas {
            width: 100% !important;

        }

        /* Styling for Specific Date Calendar */
        #specificDateCalendar {
            max-width: 250px;
            margin-top: 1rem;
            /* Ensure spacing from other elements */
        }



        /* Accordion Scroll Customization */
        .accordion .content {
            display: flex;
            flex: 0 0 auto;
            max-width: 100%;
            padding: 10px 0;
            gap: 10px;
        }

        .accordion .content::-webkit-scrollbar {
            height: 20px;
        }

        .accordion .content::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 4px;
        }

        /* Body padding */
        body {
            padding: 1em;
            background-color: #ffffff;

        }

        /* Styling for the SVG Viewer */
        #svgViewer {
            border: 1px solid #ccc;
            width: 100%;
            height: auto;
            display: block;
        }

        /* SVG Container */
        .svg-container {
            width: 100%;
            height: auto;
            max-height: 500px;
            overflow: auto;
        }

        /* Right Side Toggles - Align and Style */
        .ui.form .field .ui.toggle.checkbox {
            margin-top: 1rem;
        }

        /* Specific date picker input styling */
        #specificDateInput {
            max-width: 200px;
            margin-bottom: 10px;
        }

        /* General Form Spacing Adjustments */
        .ui.form .fields .field {
            margin-bottom: 1.5rem;
        }

        /* Toggle Alignment */
        .ui.toggle.checkbox {
            margin-top: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: flex-start;
        }

        /* Responsive Design Enhancements */
        @media (max-width: 768px) {
            .ui.stackable.grid {
                display: block;
                /* Stack content vertically on smaller screens */
            }

            .ten.wide.column {
                width: 100%;
            }

            .six.wide.column {
                width: 100%;
                margin-top: 1.5rem;
            }

            /* Adjust button margins */
            .ui.buttons>.button {
                margin-bottom: 1rem;
            }
        }

        .ui.card {
            transition: opacity 0.3s ease-in;
        }

        .ui.card[data-loaded="true"] {
            opacity: 1;
        }

        #virtual-container {
            position: relative;
            height: 100vh;
            overflow-y: auto;
        }

        #virtual-spacer {
            width: 100%;
        }

        #virtual-viewport {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
        }

        .ui.cardrtx {
            height: 250px;
            margin: 10px;
            box-sizing: border-box;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding-top: 40px;
        }

        select,
        button {
            margin-top: 10px;
            display: block;
        }

        #qrcode-wrapper {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 300px;
        }

        #qrcode {
            text-align: center;
        }

        #bottom-title {
            text-align: center;
            font-size: 18px;
            margin-top: 20px;
            padding-bottom: 70px;
        }

        @media print {

            /* Hide everything except container */
            body * {
                visibility: hidden;
            }


            .container,
            .container * {
                visibility: visible;
            }

            body,
            html {
                margin: 0;
                padding: 0;
                height: 100vh;
                width: 100vw;
                overflow: hidden;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .container {
                margin: 0;
                padding: 0;
                height: auto;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                page-break-after: avoid;
                page-break-before: avoid;
                page-break-inside: avoid;
            }



            #qrcode-wrapper {
                margin: 0;
                padding: 0;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            #qrcode {
                margin: 0;
            }

            #bottom-title {
                margin-top: 8px;
                /* tight spacing */
                font-size: 18px;
                text-align: center;
            }
        }

        #summaryChart {
            width: 50%;
        }
    </style>

</head>

<body>

    <!-- Global Loader Overlay -->
    <div id="globalLoader" class="ui active  dimmer" style="display: none;   position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;">
        <div class="ui text loader fast teal ">
            Loading...

            <div class="ui teal progress" data-percent="0" id="progressBar">
                <div class="bar"></div>
            </div>
        </div>

    </div>
    <!-- Top Fixed Menu -->
    <div class="ui top fixed menu stackable fluid five item" style="z-index: 1000; height: 4rem;">
        <!-- Logo and Title -->
        <div class="item ">
            <h3 class="ui header ">
                <span style="display: inline-flex; align-items: center;">
                    <i class="shield alternate icon teal" style="margin-right: 8px;"></i>
                    AssureVision
                </span>
                <div class="sub header">Engineered by Keith Carter</div>
            </h3>

        </div>

        <!-- Action Buttons -->
        <div class="item" id="action-btns">
            <div class="ui ">
                <button class="ui  button circular teal" id="folderPicker">

                    <span id="dirHandle"><i class="folder open icon"></i>Folder</span>
                </button>
                <button class="ui  button circular icon teal basic" id="reloadBtn">
                    <i class="redo icon"></i>

                </button>
            </div>
        </div>

        <div class="item">
            <div class="ui search  fluid " id="searchQry">
                <input class="prompt" type="text" placeholder="Search...">
                <div class="results"></div>
            </div>
        </div>

        <!-- Date Filter Dropdown -->
        <div class="item">
            <div style="margin-left:1%;">
                <div class="ui three column grid">
                    <div class="row">
                        <div class="column">
                            <div class="ui calendar" id="rangestart">
                                <div class="ui button circular tiny">Start Date</div>
                            </div>
                        </div>
                        <div class="column">
                            <div class="ui calendar" id="rangeend">
                                <div class="ui button circular tiny">End Date</div>
                            </div>
                        </div>
                        <div class="column">
                            <div id="clearDates">
                                <div class="ui button circular tiny">Clear Date</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="item ">
            <button class="ui orange circular button" id="startTourBtn">
                <i class="compass alternate icon " style="margin-right: 8px;"></i>
                Start Tour
            </button>

        </div>
    </div>

    <div class="ui top fixed menu stackable fluid three " style="z-index: 999; height: 4rem; top:4em;  ">
        <div class=" header item ">Filter & Sort</div>
        <div class="item  ">
            <div class="ui form " style="margin-top: 1em; ">
                <div class=" fields inline ">
                    <div class="field six wide labeled ">
                        <div class="ui label">Start Time</div>
                        <input type="time" id="startTimeInput" />
                    </div>
                    <div class="field six wide labeled">
                        <div class="ui label">End Time</div>
                        <input type="time" id="endTimeInput" />
                    </div>
                    <div class="field four wide">
                        <div class="ui buttons circular ">
                            <button class="ui blue small basic  button " id="applyFilterBtn">Apply</button>
                            <button class="ui basic small  button " id="applyFilterClearBtn">
                                Clear
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="item">
            <div class="ui dropdown selection groupKey">
                <i class="dropdown icon"></i>
                <div class="default text">Select Part Number</div>
                <div class="menu" id="groupKey">
                </div>
            </div>
        </div>

        <!-- Filter Dropdown -->
        <div class="item">
            <div class="ui selection dropdown" id="filterDropdown">
                <input type="hidden" name="filter" />
                <i class="dropdown icon"></i>
                <div class="default text">Select Filter</div>
                <div class="menu">
                    <div class="item" data-value="">All</div>
                    <!-- Add more filter items dynamically -->
                </div>
            </div>
        </div>

        <div class="item  ">
            <div class="ui icon button black circular" id="sortByDateBtn" title="Toggle sort direction">
                <i class="sort amount down icon"></i>
            </div>
        </div>
    </div>

    <!-- Sidebar -->
    <div class="ui left vertical  sidebar menu stackable visible  inverted" style="top: 8em; ">
        <div class="item">
            <div class="ui mini progress teal " id="toast-progress" data-percent="0">
                <div class="bar"></div>
            </div>
        </div>
        <div class="item">
            <div class="header">Main</div>
            <a class="item active" data-tab="dashboard-page">
                <div id="iconLabelDash"></div> <i class="dashboard grey icon" id="iconDashboard"></i>Dashboard
            </a>
            <a class="item" data-tab="chart-page">Charts <i class="chart bar line grey icon" id="iconCharts">
                </i> </a>
            <a class="item" data-tab="system-page">System Health <i class="heartbeat  grey  icon"
                    id="iconSystemHealth"></i></a>
            <a class="item" data-tab="image-page">Image Deck <i class="images outline grey   icon"
                    id="iconImaging"></i></a>
            <a class="item" data-tab="qr-page">QR<i class="barcode icon grey "></i></a>
        </div>
        <div class="item">
            <div class="header">Settings</div>
            <a class="item" data-tab="setting-page"> <i class="sync grey icon"></i> Auto Sync</a>
            <a class="item" data-tab="setting-grid"> <i class="ruler combined grey icon"></i> Image Layout</a>

        </div>
    </div>

    <!-- Main content container with left margin -->
    <div class="pusher" style=" margin-top: 5em; padding: 1em;">

        <div class="ui divider hidden"></div>
        <!-- Tab 1: Dashboard Stats -->
        <div class="ui grid active tab" data-tab="dashboard-page">
            <!-- Tab 1: Dash View -->
            <div class="row">
                <div class="ui  column twelve wide">

                    <!-- Tab Menu -->
                    <div class="ui top  tabular menu stackable secondary pointing teal  ">
                        <a class="item active" data-tab="dashboard">Dasshoboard</a>
                        <a class="item" data-tab="predicted">Predicted Class</a>
                        <a class="item" data-tab="trendVisualizerCard ">Trend Deck </a>

                    </div>

                    <div class="ui bottom  tab " data-tab="trendVisualizerCard ">
                        <div class=" ui grid ">
                            <div class="row">
                                <div class="column twelve wide">
                                    <div id="trend-container-card"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="ui bottom  tab " data-tab="predicted">
                        <div class=" ui grid ">
                            <div class="row">
                                <div class="column twelve wide">
                                    <div class="ui" id="stats-container-main"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="ui bottom  tab   active" data-tab="dashboard">
                        <div class=" ui grid ">
                            <div class="row">

                                <div class="column twelve wide">
                                    <div class="ui " id="stats-container-main-stats"></div>
                                    <div class=" ui divider"></div>
                                    <h4 class="ui header attached top">Cumulative Count Over Time by Prefix</h4>
                                    <div class="ui segment attached bottom" id="cumulativeCount">
                                        <canvas id="cumulativeCountChart"></canvas>
                                    </div>
                                </div>

                                <div class="column four wide">
                                    <div id="summary-container"></div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab 2: Charts  -->
        <div class="ui grid tab " data-tab="chart-page">
            <!-- Dash View -->
            <div class="row">
                <div class="ui   column twelve wide">
                    <!-- Tab Menu -->
                    <div class="ui top  tabular menu stackable secondary pointing teal  ">
                        <a class="item" data-tab="summary">Category Summary</a>
                        <a class="item active" data-tab="timeline">Timeline</a>
                        <a class="item" data-tab="trendVisualizer ">Trend Visualizer</a>
                    </div>

                    <!-- Tab 2: Category Summary -->
                    <div class="ui bottom  tab " data-tab="summary">
                        <div class="ui grid ">
                            <div class="row">
                                <div class="column twelve wide">
                                    <div class=" ui header attached top" id="summary-header">Grouped Comparison of Field
                                        Values</div>
                                    <div class="ui segment attached bottom">
                                        <canvas id="summaryChart"></canvas>
                                    </div>
                                </div>
                                <div class="column four wide">
                                    <div class="ui segment">
                                        <h4 class="ui dividing header">View Options</h4>

                                        <div class="ui toggle checkbox">
                                            <input type="checkbox" id="stackToggle">
                                            <label>Stacked View</label>
                                        </div>
                                    </div>
                                </div>

                            </div>
                        </div>
                    </div>

                    <!-- Tab 3: Timeline -->
                    <div class="ui bottom active tab " data-tab="timeline">
                        <div class="ui grid">
                            <div class="row">

                                <div class="twelve wide column">
                                    <div class="ui header attached top">Filtered Timeline (Time on X-axis)</div>
                                    <div class="ui segment attached bottom">
                                        <canvas id="timelineChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tab 4: Trend Visualizer -->
                    <div class="ui bottom  tab " data-tab="trendVisualizer ">
                        <div class=" ui grid ">
                            <div class="row">
                                <div class="column twelve wide">
                                    <div id="trend-container"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- Tab 3: System  -->
        <div class="ui grid tab " data-tab="system-page">
            <!-- Dash View -->
            <div class="row">
                <div class="ui column sixteen wide">
                    <!-- Tab Menu -->
                    <div class="ui top  tabular menu stackable secondary pointing teal  ">
                        <a class="item active" data-tab="health-chart">Health Chart</a>
                        <a class="item" data-tab="health-summary">Summary</a>
                    </div>

                    <div class="ui grid tab active " data-tab="health-chart">
                        <div class="row">
                            <div class="column twelve wide">
                                <div class="ui header attached top">Job Count Over Time (Pass vs Fail, by Prefix)</div>
                                <div class="ui segment attached bottom">
                                    <div class="ui" id="system-health-label"></div>
                                    <canvas id="heartbeatChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>


                    <div class="ui grid tab " data-tab="health-summary">
                        <div class="row">
                            <div class="column twelve wide">
                                <div class="ui  ">
                                    <div class="ui" id="stats-container"></div>
                                </div>
                            </div>
                        </div>
                    </div>


                </div>
            </div>
        </div>

        <!-- Tab 4: Images  -->
        <div class="ui grid tab " data-tab="image-page">
            <!-- Dash View -->
            <div class="row">
                <div class="ui  basic column twelve wide" style="display: block; ">
                    <!-- Tab Menu 
                    <div class="ui top  tabular menu stackable secondary pointing teal  ">
                        <a class="item active" data-tab="info-card-deck-view">Info Deck</a>
                        <a class="item" data-tab="imageView">Image Preview</a>
                    </div>-->

                    <!-- Tab 5: Info Deck Stats -->
                    <div class="ui active   segment basic " data-tab="info-card-deck-view">

                        <!-- Card View -->
                        <div class="ui cards three stackable" id="cardGridContainer">
                            <!-- Cards dynamically injected here -->
                            <div id="cardGridSpacerTop"></div>
                            <div class="ui cards three stackable" id="cardGridInner"></div>
                            <div id="cardGridSpacerBottom"></div>
                        </div>
                        <div id="virtual-container">
                            <div id="virtual-spacer"></div>
                            <div id="virtual-viewport"></div>
                        </div>

                    </div>

                    <!-- Tab 6:  Image Preview & Data -->
                    <div class="ui  tab segment basic " data-tab="imageView">

                    </div>
                </div>
            </div>
        </div>

        <!-- Tab 5: QR  -->
        <div class="ui grid tab " data-tab="qr-page">
            <!-- Dash View -->
            <div class="row">
                <div class="ui  basic column twelve wide" style="display: block; ">

                    <!-- Tab 6:  Qr -->
                    <div class="ui  " data-tab="qrMakerView">
                        <div class="container">
                            <h2>QR Code Generator</h2>

                            <label for="preset-select">Choose a preset:</label>
                            <select id="preset-select">
                                <option value="">-- Select a preset --</option>
                            </select>

                            <button id="generate-btn">Generate QR Code</button>

                            <div id="qrcode-wrapper">
                                <div id="qrcode"></div>
                            </div>

                            <div id="bottom-title"></div>
                        </div>
                    </div>

                </div>
            </div>
        </div>

        <!-- Tab 6: Setting  -->

        <div class="ui grid tab " data-tab="setting-page">
            <!-- Dash View -->
            <div class="ui header">Settings</div>
            <div class="row">
                <div class="ui  basic column twelve wide" style="display: block; ">
                    <!-- Right-aligned Cog Icon (Optional) -->
                    <div class="ui segment aligned left">
                        <div class="ui toggle checkbox">
                            <input type="checkbox" id="autoReloadToggle" />
                            <label>Auto-Reload</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="ui grid tab " data-tab="setting-grid">
            <!-- Dash View -->
            <div class="ui header">Settings</div>
            <div class="row">
                <div class="ui  basic column twelve wide" style="display: block; ">
                    <!-- Right-aligned Cog Icon (Optional) -->
                    <div class="ui segment aligned left">
                        <div class="ui toggle checkbox card-grid">
                            <input type="checkbox" id="cardGridToggle" />
                            <label id="gridLabel"> Show List</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Fullscreen Overlay Modal -->
    <div class="ui overlay fullscreen modal">
        <i class="close icon"></i>
        <div class="header modal-header">
            Fullscreen Image
        </div>
        <div class="content modal-content">
            <!-- Single Image View -->
            <div id="imageView" class="ui stackable grid">
                <div class="ten wide column">
                    <div class="ui segment">
                        <h4 class="ui header">Preview</h4>
                        <object id="svgViewer" type="image/svg+xml"></object>
                        <button class="ui green button" id="saveBtn" style="margin-top: 1rem;">
                            <i class="save icon"></i>
                            Train
                        </button>

                    </div>
                </div>

                <div class="six wide column">

                    <div class="ui segment">
                        <h4 class="ui header">Associated Data</h4>
                        <div style="overflow-x: auto;">
                            <table class="ui celled compact small table">
                                <thead>
                                    <tr>
                                        <th>Key</th>
                                        <th>Value</th>
                                    </tr>
                                </thead>
                                <tbody id="dataTable">
                                    <!-- Dynamic Rows -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class=" ui segment">
                        <h4 class="ui header">Playback Controls</h4>

                        <div id="slideshowControls" class="ui buttons small circular">
                            <button class="ui button icon" id="prevBtn"><i class="step backward icon"></i></button>
                            <button class="ui teal button icon" id="playBtn"><i class="play icon"></i></button>
                            <button class="ui red button icon" id="pauseBtn"><i class="pause icon"></i></button>
                            <button class="ui button icon" id="nextBtn"><i class="step forward icon"></i></button>


                        </div>
                        <button class="ui compact menu button small circular">
                            <div class=" ui simple dropdown item">
                                Speed
                                <i class="dropdown icon"></i>
                                <div class="menu">
                                    <div class="item" data-speed="1000">1s</div>
                                    <div class="item" data-speed="3000">3s</div>
                                    <div class="item" data-speed="5000">5s</div>
                                </div>
                            </div>
                        </button>
                    </div>
                    <div class="ui segment">
                        <div class="item">
                            <h4 class="ui dividing header">Available Images (Grouped by Prefix)</h4>
                            <div class="ui styled fluid accordion" id="imageList"></div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
        <div class="actions">
            <div class="ui red cancel button">Close</div>
        </div>
    </div>

    <script type="module">


        class VirtualCardRenderer {
            constructor(containerId, files, buildCardContent, cardHeight = 270, buffer = 5) {
                this.container = document.getElementById(containerId);
                this.viewport = this.container.querySelector('#virtual-viewport');
                this.spacer = this.container.querySelector('#virtual-spacer');
                this.files = files; // your file metadata list
                this.buildCardContent = buildCardContent;
                this.cardHeight = cardHeight;
                this.buffer = buffer;

                this.total = files.length;
                this.cardsInView = 0;

                this.init();
            }

            init() {
                this.container.addEventListener('scroll', () => this.renderVisibleCards());
                this.spacer.style.height = `${this.total * this.cardHeight}px`;
                this.renderVisibleCards();
            }

            renderVisibleCards() {
                const scrollTop = this.container.scrollTop;
                const containerHeight = this.container.clientHeight;

                const startIndex = Math.max(0, Math.floor(scrollTop / this.cardHeight) - this.buffer);
                const endIndex = Math.min(
                    this.total,
                    Math.ceil((scrollTop + containerHeight) / this.cardHeight) + this.buffer
                );

                // Clear current viewport
                this.viewport.innerHTML = '';

                // Render visible cards
                for (let i = startIndex; i < endIndex; i++) {
                    const file = this.files[i];

                    const card = document.createElement('div');
                    card.className = 'ui card';
                    card.style.position = 'absolute';
                    card.style.top = `${i * this.cardHeight}px`;
                    card.dataset.index = i;

                    this.buildCardContent(card, file); // Can be async if needed
                    this.viewport.appendChild(card);
                }
            }
        }

        class TextSaver {
            static storageKey = 'textSaverContent';
            static userId = 'user123'; // Replace with actual logic/session ID
            static endpoint = `/api/notes/${TextSaver.userId}.json`;

            // Initialize: fetch from server, update localStorage & textarea
            static async init() {
                const textarea = document.getElementById('textInput');

                try {
                    const res = await fetch(TextSaver.endpoint);
                    if (!res.ok) throw new Error('Fetch failed');
                    const data = await res.json();
                    localStorage.setItem(TextSaver.storageKey, data.content || '');
                } catch (err) {
                    console.warn("Could not fetch server note, falling back to localStorage", err);
                }

                textarea.value = localStorage.getItem(TextSaver.storageKey) || '';

                textarea.addEventListener('input', () => {
                    localStorage.setItem(TextSaver.storageKey, textarea.value);
                });
            }

            static saveText() {
                const text = localStorage.getItem(TextSaver.storageKey) || '';
                const blob = new Blob([text], { type: 'text/plain' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'note.txt';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            static openText() {
                const text = localStorage.getItem(TextSaver.storageKey) || '';
                const newWindow = window.open();
                newWindow.document.write(`<pre>${TextSaver.escapeHtml(text)}</pre>`);
                newWindow.document.title = "Note View";
            }

            static escapeHtml(str) {
                return str
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }
        }

        class TrendVisualizerCards {
            constructor(containerId, dataArray, animatedCounter, updateSearch) {
                this.statCard = null;
                this.container = document.getElementById(containerId);
                if (!this.container) {
                    throw new Error(`Container with ID "${containerId}" not found.`);
                }
                this.animatedCounter = animatedCounter;
                this.processedData = this.analyzeTrends(dataArray);
                this.sortingOrder = false;
                this.filterValue = null;
                this.isUpdating = false;
                this.updateSearch = updateSearch

                this.render();
                this.init();

            }

            init() {
                try {
                    document.querySelectorAll('.fail-counter').forEach(el => {
                        const target = parseInt(el.getAttribute('data-value'));
                        if (typeof this.animatedCounter === 'function') {
                            this.animatedCounter(el, target);
                        } else {
                            console.warn("animatedCounter is not a function:", this.animatedCounter);
                        }
                    });

                    document.querySelectorAll('.ellipsis.icon').forEach(el => {
                        $('.dropdown.ellipsis').dropdown({
                            onChange: (value) => {
                                this.filterMap(value);
                                if (value.includes('filter')) {
                                    const formattedValue = value.split(' ')[1];
                                    this.updateSearch(formattedValue);
                                }
                            }
                        })
                    });

                    this.statCard = document.querySelectorAll('.stat-card');

                } catch (error) {
                    console.warn(error);
                }
            }
            updatingBool() {
                this.statCard.forEach(el => {
                    el.classList.remove('loading');
                });

            }

            filterMap(value) {
                const sortedData = [...this.processedData].sort((a, b) => {
                    switch (value) {
                        case 'date':
                            return new Date(b.date) - new Date(a.date)

                        case 'color':
                            return b.color.localeCompare(a.color)

                        case 'group key':
                            return a.groupKey.localeCompare(b.groupKey)
                        case 'total fail':
                            return b.totalFail - a.totalFail

                        case 'total pass':
                            return a.totalPass - b.totalPass

                        case 'most seen classification failure':
                            return b.mostSeenClassificationFailure.localeCompare(a.mostSeenClassificationFailure)

                        case 'fail to pass ratio':
                            return b.failToPassRatio - a.failToPassRatio

                        default:
                            return 0;
                    }
                });
                this.processedData = sortedData;
                this.render();
                this.init();
                this.updatingBool();

            }

            analyzeTrends(dataArray) {
                const grouped = {};

                dataArray.forEach(item => {
                    const groupKey = item.groupKey;
                    const date = new Date(item.date).toISOString().split('T')[0];
                    const key = `${groupKey}__${date}`;

                    if (!grouped[key]) {
                        grouped[key] = {
                            groupKey,
                            date,
                            totalFail: 0,
                            totalPass: 0,
                            classificationFailures: {}
                        };
                    }

                    const group = grouped[key];
                    const fail = this.extractLabelValue(item.labels, 'Job.Fail');
                    const pass = this.extractLabelValue(item.labels, 'Job.Pass');

                    group.totalFail += fail;
                    group.totalPass += pass;

                    if (fail > 0) {
                        item.labels.forEach(label => {
                            if (label.startsWith('Classify_') && !label.includes('OK')) {
                                group.classificationFailures[label] = (group.classificationFailures[label] || 0) + 1;
                            }
                        });
                    }
                });

                return Object.values(grouped).map(group => {
                    const mostSeenFailure = Object.entries(group.classificationFailures).sort((a, b) => b[1] - a[1])[0];

                    const fTRatio = group.totalPass > 0 ? +(group.totalFail / group.totalPass).toFixed(2) : '0.00'

                    const color =
                        (fTRatio === '0.00') ? "blue" :
                            (fTRatio < .05) ? "green" :
                                (fTRatio <= .15) ? "orange" : "red"

                    return {
                        color: color,
                        groupKey: group.groupKey,
                        date: group.date,
                        totalFail: group.totalFail,
                        totalPass: group.totalPass,
                        failToPassRatio: group.totalPass > 0 ? (group.totalFail / group.totalPass).toFixed(2) : 0,
                        mostSeenClassificationFailure: mostSeenFailure ? mostSeenFailure[0].split('=')[1] : 'None'
                    };
                });
            }

            extractLabelValue(labels, key) {
                const label = labels.find(l => l.startsWith(`${key}=`));
                return label ? parseInt(label.split('=')[1], 10) : 0;
            }

            render() {
                this.container.innerHTML = '';

                const cardGrid = document.createElement('div');
                cardGrid.className = 'ui stackable cards big  three basic';

                this.processedData.forEach(data => {
                    const card = this.createCard(data);
                    cardGrid.appendChild(card);
                });

                this.container.appendChild(cardGrid);
            }



            createCard(data) {
                const color = data.color;

                const card = document.createElement('div');
                card.className = `ui card fluid stat-card    ${color}`;

                // Header
                const header = document.createElement('div');
                header.className = 'content';
                const [year, month, day] = data.date.split('-').map(Number);
                const dateFormatted = new Date(year, month - 1, day); // correct local date

                const formatted = new Intl.DateTimeFormat('en-US', {
                    year: '2-digit',
                    month: '2-digit',
                    day: '2-digit'
                }).format(dateFormatted);

                header.innerHTML = `
            <div class="header">${data.groupKey}</div>
            <div class="right floated header  ">
                <button class='button circular ui white inverted   mini icon dropdown ellipsis'>  
                    <i class="ellipsis vertical icon" style="visibility: visible;"></i>
                
              
                <div class=" menu">
                   
                            <div class="item">Filter ${data.groupKey}</div> 

                    <div class="item">Date</div>
                    <div class="item">Color</div>
                    <div class="item">Group Key</div>
                    <div class="item">Fail To Pass Ratio</div>
                    <div class="item">Total Fail</div>
                    <div class="item">Total Pass</div>
                    <div class="item">Most Seen Classification Failure</div>

                  
                    </div>
                    </button>
                </div>
            <div class="meta">${formatted}</div>
        `;

                // Stats
                const stats = document.createElement('div');
                stats.className = 'content';
                stats.appendChild(this.createStats(data));

                const extraContent = document.createElement('div');
                extraContent.className = 'extra content';

                const cardLabel = document.createElement('div');
                cardLabel.className = `ui button ${color}  `;
                cardLabel.textContent = ` Top Failure: ${data.mostSeenClassificationFailure}`;

                extraContent.appendChild(cardLabel);

                card.appendChild(header);
                card.appendChild(stats);
                card.appendChild(cardLabel);
                return card;
            }

            createStats(data) {
                const statsWrapper = document.createElement('div');
                statsWrapper.className = 'ui four small statistics ';

                const stats = [
                    { label: 'Fails', value: data.totalFail, color: 'red' },
                    { label: 'Passes', value: data.totalPass, color: 'green' },
                    { label: 'Ratio', value: data.failToPassRatio, color: 'blue' },
                ];

                stats.forEach(stat => {
                    const div = document.createElement('div');
                    div.className = `ui statistic fluid  inverted `;
                    div.innerHTML = `

                <div class="value ${stat.label.includes('Fails') || stat.label.includes('Pass') ? "fail-counter" : null}"  data-value="${stat.value}">${stat.value}</div>
                <div class="label">${stat.label}</div>
            `;
                    statsWrapper.appendChild(div);
                });

                return statsWrapper;
            }
        }

        class TrendVisualizer {
            constructor(containerId, dataArray) {
                this.container = document.getElementById(containerId);
                if (!this.container) {
                    throw new Error(`Container with ID "${containerId}" not found.`);
                }

                this.processedData = this.analyzeTrends(dataArray);

                this.render();
                this.init();
            }

            init() {
                $(document).on('ready', () => { $('table').tablesort() });

            }
            analyzeTrends(dataArray) {
                const grouped = {};

                dataArray.forEach(item => {

                    const groupKey = item.groupKey;
                    const date = new Date(item.date).toISOString().split('T')[0];
                    const key = `${groupKey}__${date}`;

                    if (!grouped[key]) {
                        grouped[key] = {
                            groupKey,
                            date,
                            totalFail: 0,
                            totalPass: 0,
                            classificationFailures: {}
                        };
                    }

                    const group = grouped[key];
                    const fail = this.extractLabelValue(item.labels, 'Job.Fail');
                    const pass = this.extractLabelValue(item.labels, 'Job.Pass');

                    group.totalFail += fail;
                    group.totalPass += pass;

                    if (fail > 0) {
                        item.labels.forEach(label => {
                            if (label.startsWith('Classify_') && !label.includes('OK')) {
                                group.classificationFailures[label] = (group.classificationFailures[label] || 0) + 1;
                            }
                        });
                    }
                });

                return Object.values(grouped).map(group => {
                    const mostSeenFailure = Object.entries(group.classificationFailures).sort((a, b) => b[1] - a[1])[0];
                    return {
                        groupKey: group.groupKey,
                        date: group.date,
                        totalFail: group.totalFail,
                        totalPass: group.totalPass,
                        failToPassRatio: group.totalPass > 0 ? (group.totalFail / group.totalPass).toFixed(2) : 0,
                        mostSeenClassificationFailure: mostSeenFailure ? mostSeenFailure[0].split('=')[1] : 'None'
                    };
                });
            }

            extractLabelValue(labels, key) {
                const label = labels.find(l => l.startsWith(`${key}=`));
                return label ? parseInt(label.split('=')[1], 10) : 0;
            }

            render() {

                // Clear previous content
                this.container.innerHTML = '';

                // Create layout
                const chartCanvas = document.createElement('canvas');
                const table = document.createElement('table');
                table.className = 'ui  table  sortable';

                this.container.appendChild(chartCanvas);
                this.container.appendChild(document.createElement('br'));
                this.container.appendChild(table);

                this.renderChart(chartCanvas);
                this.renderTable(table);

            }

            renderChart(canvas) {
                const labels = this.processedData.map(d => `${d.groupKey} (${d.date})`);
                const fails = this.processedData.map(d => d.totalFail);
                const passes = this.processedData.map(d => d.totalPass);

                new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels,
                        datasets: [
                            {
                                label: 'Fails',
                                backgroundColor: 'rgba(255, 99, 132, 0.6)',
                                data: fails
                            },
                            {
                                label: 'Passes',
                                backgroundColor: 'rgba(75, 192, 192, 0.6)',
                                data: passes
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'top'
                            },
                            title: {
                                display: true,
                                text: 'Fail vs Pass Trend'
                            }
                        },
                        scales: {
                            x: {
                                stacked: true
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            renderTable(table) {

                table.innerHTML = `
            <thead>
                <tr >
                    <th >Part Number </th>
                    <th class="sorted ascending ">Date</th>
                    <th>Fails</th>
                    <th>Passes</th>
                    <th>Fail:Pass Ratio</th>
                    <th>Most Seen Failure</th>
                </tr>
            </thead>
            <tbody>
                ${this.processedData.map((d, i) => `
                    <tr>
                        <td>${d.groupKey}</td>
                        <td>${d.date}</td>
                        <td>${d.totalFail}</td>
                        <td>${d.totalPass}</td>
                        <td class="${(d.failToPassRatio === 0) ? "blue" : (d.failToPassRatio < .05) ? "green" : (d.failToPassRatio >= .05 && d.failToPassRatio <= .15) ? "yellow" : "red"}">${d.failToPassRatio}%</td>
                        <td>${d.mostSeenClassificationFailure}</td>
                    </tr>
                `).join('')}
            </tbody>
        `;
            }
        }

        class WorkerPool {
            constructor(workerScriptUrl, poolSize = 4) {
                this.workerScriptUrl = workerScriptUrl;
                this.poolSize = poolSize;
                this.workers = [];
                this.queue = [];
                this.active = 0;
            }

            runTask(taskData) {
                return new Promise((resolve, reject) => {
                    const task = { taskData, resolve, reject };
                    this.queue.push(task);
                    this.runNext();
                });
            }

            runNext() {
                if (this.active >= this.poolSize || this.queue.length === 0) return;

                const worker = new Worker(this.workerScriptUrl);
                const { taskData, resolve, reject } = this.queue.shift();

                this.active++;

                worker.postMessage(taskData);

                worker.onmessage = (e) => {
                    worker.terminate();
                    this.active--;
                    resolve(e.data);
                    this.runNext();
                };

                worker.onerror = (err) => {
                    worker.terminate();
                    this.active--;
                    reject(err);
                    this.runNext();
                };
            }
        }

        class FolderManager {
            constructor() {
                this.folderPicker = document.getElementById('folderPicker');
                this.imageList = document.getElementById('imageList');
                this.svgViewer = document.getElementById('svgViewer');
                this.dataViewer = document.getElementById('dataViewer');
                this.saveBtn = document.getElementById('saveBtn');
                this.viewToggle = document.getElementById('viewToggle');
                this.chartView = document.getElementById('chartView');
                this.imageView = document.getElementById('imageView');
                this.autoReloadToggle = document.getElementById('autoReloadToggle');
                this.cardGridToggleBool = document.getElementById('cardGridToggle');
                this.clearDates = document.getElementById('clearDates');

                this.modalHeader = document.getElementById('modal-header');
                this.modalContent = document.getElementById('modal-content');
                this.gridLabel = document.getElementById('gridLabel');
                this.stackToggle = document.getElementById('stackToggle');
                this.reloadBtn = document.getElementById('reloadBtn');
                this.folderName = document.getElementById('dirHandle');
                this.statsHtml = document.getElementById('stats-container');
                this.statsHtmlMain = document.getElementById('stats-container-main');
                this.statsHtmlMainHeaderStats = document.getElementById('stats-container-main-stats');
                this.summaryContainer = document.getElementById('summary-container');
                this.summaryHeader = document.getElementById('summary-header');
                this.systemHealthHtmlLabel = document.getElementById('system-health-label');
                this.sortBtn = document.getElementById('sortByDateBtn');
                this.progressData = document.getElementById('progressData')
                this.summaryChartCtx = document.getElementById('summaryChart')?.getContext('2d');
                this.timelineChartCtx = document.getElementById('timelineChart')?.getContext('2d');
                this.heartbeatChartCtx = document.getElementById('heartbeatChart').getContext('2d');
                this.cumulativeCountChartCtx = document.getElementById('cumulativeCountChart').getContext('2d');

                this.playSlideshowBtn = document.getElementById('playSlideshowBtn');
                this.saved = JSON.parse(localStorage.getItem('savedFilenames') || '[]');
                this.applyFilterBtn = document.getElementById('applyFilterBtn');
                this.applyFilterClearBtn = document.getElementById('applyFilterClearBtn');
                this.startTimeInputCardGrid = document.getElementById('startTimeInputCardGrid');
                this.endTimeInputCardGrid = document.getElementById('endTimeInputCardGrid');
                this.startTimeInput = document.getElementById('startTimeInput');
                this.endTimeInput = document.getElementById('endTimeInput');

                this.select = document.getElementById('preset-select');
                this.button = document.getElementById('generate-btn');
                this.qrcodeContainer = document.getElementById('qrcode');
                this.bottomTitle = document.getElementById('bottom-title');

                this.dropNumSearch = document.getElementById('groupKey');
                this.clearDateBtn = document.getElementById('clearDateBtn');

                this.cardGridContainer = document.getElementById('cardGridContainer');
                this.cardGridInner = document.getElementById('cardGridInner');
                this.cardGridSpacerTop = document.getElementById('cardGridSpacerTop');
                this.cardGridSpacerBottom = document.getElementById('cardGridSpacerBottom');

                this.presets = [
                    {
                        en: "Machine Repeatedly Rejecting Parts\nThe system is currently rejecting most or all parts. Please investigate reject logic or sensor alignment.",
                        es: "Máquina rechazando piezas repetidamente"
                    },
                    {
                        en: "Operator Needs Assistance\nImmediate help required. The operator is unable to proceed due to an issue with the machine or process.",
                        es: "Operador necesita asistencia"
                    },
                    {
                        en: "Quality Hold, Do Not Operate\nThis machine is under quality review. Do not resume operation until cleared by QA or Engineering.",
                        es: "Retención por calidad, No operar"
                    },
                    {
                        en: "Engineering Currently Training the Machine\nEngineering team is configuring or learning machine behavior for optimization. Please do not interrupt.",
                        es: "Ingeniería entrenando la máquina"
                    },
                    {
                        en: "In Testing Phase , Use with Caution\nThe machine is undergoing testing. Results may be inconsistent. Only authorized personnel should operate.",
                        es: "En fase de prueba , Usar con precaución"
                    },
                    {
                        en: "Machine Offline for Maintenance\nThis machine is temporarily shut down for preventive or corrective maintenance.",
                        es: "Máquina fuera de línea por mantenimiento"
                    },
                    {
                        en: "Fault in Box Feeder/Loader Detected\nThere is an issue with the material feed or loading mechanism. Check for jams or misfeeds.",
                        es: "Falla detectada en el alimentador/cargador de cajas"
                    },
                    {
                        en: "Under Investigation by Engineering\nA technical issue has been reported and is being actively investigated by Engineering.",
                        es: "Bajo investigación por ingeniería"
                    },
                    {
                        en: "Machine in Calibration Mode\nDo not run production , the system is being calibrated for accuracy and alignment.",
                        es: "Máquina en modo de calibración"
                    },
                    {
                        en: "Material Issue Detected\nIncorrect or incompatible material detected. Verify material specs and replace if needed.",
                        es: "Problema de material detectado"
                    },
                    {
                        en: "Process Adjustment in Progress\nSettings or parameters are being modified for optimization. Please wait for completion.",
                        es: "Ajuste de proceso en curso"
                    },
                    {
                        en: "Temporarily Halted Due to Safety Concern\nA potential safety issue has been identified. Await clearance from Safety/Engineering.",
                        es: "Detenido temporalmente por motivo de seguridad"
                    },
                    {
                        en: "Rebooting , Wait for System Restart\nMachine is currently rebooting. Operation will resume shortly.",
                        es: "Reiniciando , Esperando reinicio del sistema"
                    },
                    {
                        en: "Waiting for Parts/Consumables\nMachine idle due to lack of materials or required consumables. Supply pending.",
                        es: "Esperando piezas/consumibles"
                    }
                ];

                this.filterString = '';
                this.search = null;
                this.dateFilter = null;
                this.selectedDate = null;
                this.timeSeriesData = [];
                this.summaryData = {};
                this.availableFilters = new Set();
                this.currentFilename = null;
                this.chartInstance = null;
                this.timelineChartInstance = null;
                this.cumulativeCountChartInstance = null;
                this.autoReloadInterval = null;
                this.dirHandle = null;
                this.searchTheseNames = [];
                this.progressBar = 0;
                this.dates = [];

                this.colors = [
                    "red", "orange", "yellow", "olive", "green", "teal", "blue", "violet", "purple", "pink",
                    "grey", "black"
                ]

                this.slideshowInterval = null;
                this.slideshowIndex = 0;
                this.slideshowFiles = [];
                this.slideshowIndex = 0;
                this.slideshowTimer = null;
                this.slideshowSpeed = 3000; // default: 3 seconds
                this.startTime = null;
                this.endTime = null;
                this.rangestart = null;
                this.rangeend = null;

                this.cachedFiles = []; // will store all parsed files after initial read
                this.groupKey = [];
                this.arryInfo = null;
                this.sortByRecent = false; // default: no sorting
                this.updateProgress = 0;
                this.gridControl = { grid: ['three'], list: ['one', 'horizontal'] };

                this.isStacked = false;
                this.selectedCardData = null;
                this.trendVisualizer = null;
                this.updateSearch = this.updateSearch.bind(this);

                this.cardHeight = 404 * 3; // Estimate or measure this
                this.buffer = 6;      // Buffer before/after visible range


                this.visibleCardCount = Math.ceil(this.cardGridContainer.clientHeight / this.cardHeight);
                this.filteredFiles = null;
                this.init();

            }

            animatedCounter(el, target) {

                let start = 0;
                const duration = 1000; // 1 second
                const startTime = performance.now();

                const update = (currentTime) => {
                    const progress = Math.min((currentTime - startTime) / duration, 1);
                    const value = Math.floor(start + (Number(target) - start) * progress);
                    el.textContent = value;

                    if (progress < 1) {
                        requestAnimationFrame(update);
                    }
                };

                requestAnimationFrame(update);
            }

            init() {
                this.folderPicker?.addEventListener('click', () => this.selectFolder());
                this.stackToggle?.addEventListener('change', () => {
                    this.summaryHeader.innerText =
                        !this.isStacked ?
                            'Stacked Comparison of Field Values' :
                            'Grouped Comparison of Field Values'
                    this.isStacked = !this.isStacked;
                    this.renderSummaryChart();

                });
                this.reloadBtn?.addEventListener('click', () => this.readFolderContents());
                this.viewToggle?.addEventListener('change', () => this.toggleView());
                this.autoReloadToggle?.addEventListener('change', () => this.toggleAutoReload());
                this.clearDateBtn?.addEventListener('click', () => this.clearDate())
                this.saveBtn?.addEventListener('click', () => this.toggleSave());
                this.cardGridView = document.getElementById('cardGridView');
                this.cardGridToggleBool?.addEventListener('change', () => this.imageGridSettings())

                this.setupSlideshowControls();
                this.sortBtn?.addEventListener('click', () => {
                    this.sortByRecent = !this.sortByRecent;
                    this.sortBtn.innerHTML = this.sortByRecent ?
                        `<i class="sort amount down icon"></i>` :
                        `<i class="sort amount up icon"></i>`;
                    this.filterAndRenderFiles();
                });
                $('.ui.search').search({
                    source: [],
                    onSearchQuery: function (query) {
                        if (!query.trim()) {
                            // Reset the search results when query is empty
                            this.search = null; // If you have a custom reset function
                            this.filterAndRenderFiles();

                            return;
                        }

                        this.search = query;
                        this.filterAndRenderFiles();
                    }.bind(this)
                });
                $('.groupKey').dropdown({
                    onChange: function (value, text, $selectedItem) {
                        this.search = value;
                        this.filterAndRenderFiles();
                    }.bind(this)
                });
                $('#filterDropdown').dropdown();
                $('.menu .item').tab();
                $('#progressBar').progress();
                $('#toast-progress').progress();
                $('.card-grid').checkbox();
                $(document).on('click', '.show-modal', function () {
                    $('.ui.overlay.fullscreen.modal').modal('show');
                });

                this.clearDates.addEventListener('click', () => {
                    this.clearDate();
                })

                this.applyFilterBtn.addEventListener('click', () => {
                    const startTimeStr = this.startTimeInput.value;
                    const endTimeStr = this.endTimeInput.value;

                    const baseDateStart = new Date(this.rangestart); // You already set this elsewhere
                    const baseDateEnd = new Date(this.rangeend); // You already set this elsewhere

                    if (startTimeStr) {
                        const [h, m] = startTimeStr.split(':');
                        const start1 = new Date(baseDateStart), start2 = new Date(baseDateStart);
                        start1.setHours(+h, +m, 0, 0);
                        start2.setHours(+h, +m, 0, 0);
                        this.startTime = { start1, start2 };
                    } else {
                        this.startTime = null;
                    }

                    if (endTimeStr) {
                        const [h, m] = endTimeStr.split(':');
                        const end1 = new Date(baseDateEnd), end2 = new Date(baseDateEnd);
                        end1.setHours(+h, +m, 0, 0);
                        end2.setHours(+h, +m, 0, 0);
                        this.endTime = { end1, end2 };
                    } else {
                        this.endTime = null;
                    }

                    /* this.renderTimelineChart();
                    this.renderHeartbeatChart();
                    this.renderCumulativeCountChart();
                    this.renderCardGrid(); */
                    this.filterAndRenderFiles();
                });

                window.addEventListener('scroll', () => {
                    const scrollTop = window.scrollY || document.documentElement.scrollTop;
                    this.visibleCardCount = Math.ceil(this.cardGridContainer.clientHeight / this.cardHeight);

                    const startIndex = Math.max(0, Math.floor(scrollTop / this.cardHeight) - this.buffer);
                    const endIndex = Math.min(
                        this.filteredFiles.length,
                        startIndex + this.visibleCardCount + this.buffer * 2
                    );

                    this.renderVirtualCards(startIndex, endIndex);
                });

                this.applyFilterClearBtn.addEventListener('click', () => {

                    this.startTimeInput.value = null;
                    this.endTimeInput.value = null;

                    this.startTime = null;
                    this.endTime = null;

                    /* this.renderTimelineChart();
                    this.renderCardGrid(); */
                    this.filterAndRenderFiles();
                });

                this.setCalendarDatesToDefault();
                this.setupDateDropdown();
                this.setupCalendar();
                this.showLoader();
                this.renderStats();
                this.getHealthIndicator();
                this.qrMaker();
                this.searchNumDropdown();
                this.trendVisualizer = new TrendVisualizer('trend-container', []);
                this.trendVisualizerCards = new TrendVisualizerCards('trend-container-card', [], this.animatedCounter);

                setTimeout(() => this.hideLoader(), 2000);
            }

            extractLabelValue(labels, key) {
                const label = labels.find(l => l.startsWith(`${key}=`));
                return label ? parseInt(label.split('=')[1], 10) : 0;
            }

            analyzeTrends(currentGroupKey, targetDate) {
                let totalFail = 0;
                let totalPass = 0;
                const classificationFailures = {};

                this.cachedFiles.forEach(item => {
                    const groupKey = item.groupKey;
                    const date = new Date(item.date).toISOString().split('T')[0];

                    if (groupKey !== currentGroupKey || date !== targetDate) return;

                    const fail = this.extractLabelValue(item.labels, 'Job.Fail');
                    const pass = this.extractLabelValue(item.labels, 'Job.Pass');

                    totalFail += fail;
                    totalPass += pass;

                    if (fail > 0) {
                        item.labels.forEach(label => {
                            if (label.startsWith('Classify_') && !label.includes('OK')) {
                                classificationFailures[label] = (classificationFailures[label] || 0) + 1;
                            }
                        });
                    }
                });

                const mostSeenFailure = Object.entries(classificationFailures).sort((a, b) => b[1] - a[1])[0];

                const fTRatio = totalPass > 0 ? +(totalFail / totalPass).toFixed(2) : '0.00';
                const color =
                    (fTRatio === '0.00') ? "blue" :
                        (fTRatio < 0.05) ? "green" :
                            (fTRatio <= 0.15) ? "orange" : "red";

                const iconDetails =
                    (fTRatio === '0.00') ? "ban" :
                        (fTRatio < 0.05) ? "check circle" :
                            (fTRatio < 0.15) ? "exclamation triangle" : "exclamation circle";

                return {
                    date: targetDate,
                    failToPassRatio: fTRatio,
                    color,
                    iconDetails
                };
            }

            updateSearch(response) {
                this.search = response;
                this.filterAndRenderFiles();
            }

            setCalendarDatesToDefault() {
                this.rangestart = new Date('2000-01-01T00:00:00.000Z').toISOString();
                this.rangeend = new Date().toISOString();
            }

            searchNumDropdown() {
                const f = this.cachedFiles.filter(item => this.matchesFilters(item));
                this.dropNumSearch.innerHTML = '';
                this.dropNumSearch.innerHTML =
                    this.groupKey.map(item => f.some(i => i.groupKey === item) ? `<div class="item" data-value="${item}">${item}</div>` : null).join('');
            }

            qrMaker() {
                this.presets.forEach((preset, index) => {
                    const option = document.createElement('option');
                    const titleText = preset.en.split('\n')[0];
                    option.value = index;
                    option.textContent = titleText;
                    option.setAttribute('data-fulltext', preset.en);
                    option.title = `${titleText} / ${preset.es}`;
                    this.select.appendChild(option);
                });

                this.button.addEventListener('click', () => {
                    const selectedOption = this.select.options[this.select.selectedIndex];
                    if (!selectedOption || !selectedOption.value) {
                        alert('Please select a preset message');
                        return;
                    }

                    const fullText = selectedOption.getAttribute('data-fulltext');
                    const titleText = fullText.split('\n')[0] + " / " + this.presets.find(item => fullText.split('\n')[0])?.es;

                    // Clear previous QR
                    this.qrcodeContainer.innerHTML = '';

                    // Generate QR code
                    new QRCode(this.qrcodeContainer, {
                        text: fullText,
                        width: 200,
                        height: 200,
                        colorDark: '#000000',
                        colorLight: '#ffffff',
                        correctLevel: QRCode.CorrectLevel.H
                    });

                    // Show title at the bottom
                    this.bottomTitle.textContent = titleText;

                    // Trigger print
                    setTimeout(() => {
                        window.print();
                    }, 500);
                });

            }

            getHealthIndicator() {
                const errorRate = this.getErrorRate();

                let healthStatus = '';
                let color = '';
                let icon = '';

                if (errorRate === 0) {
                    healthStatus = 'Excellent';
                    color = 'green';
                    icon = 'check circle';
                } else if (errorRate <= 5) {
                    healthStatus = 'Good';
                    color = 'olive';
                    icon = 'thumbs up';
                } else if (errorRate <= 15) {
                    healthStatus = 'Fair';
                    color = 'yellow';
                    icon = 'exclamation circle';
                } else if (errorRate <= 30) {
                    healthStatus = 'Poor';
                    color = 'orange';
                    icon = 'warning sign';
                } else {
                    healthStatus = 'Critical';
                    color = 'red';
                    icon = 'times circle';
                }

                this.systemHealthHtmlLabel.innerHTML = `
    <div class="ui icon ${color} message">
        <i class="${icon} icon"></i>
        <div class="content">
            <div class="header">
                System Health: ${healthStatus}
            </div>
            <p>Error Rate: ${errorRate.toFixed(2)}%</p>
        </div>
    </div>
`;

            }

            getRecentActivity(days = 7) {
                const cutoff = new Date();
                cutoff.setDate(cutoff.getDate() - days);
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });
                return filteredItems.filter(item => new Date(item.date) >= cutoff);
            }

            getErrorRate() {
                let totalFails = 0, totalPasses = 0;
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });
                filteredItems.forEach(item => {

                    item.labels.forEach(label => {
                        if (label.startsWith("Job.Fail=")) totalFails += parseInt(label.split("=")[1]);
                        if (label.startsWith("Job.Pass=")) totalPasses += parseInt(label.split("=")[1]);
                    });
                });

                const total = totalFails + totalPasses;
                return total === 0 ? 0 : (totalFails / total) * 100;
            }

            getMostCommonPredictedClass() {
                const classCounts = {};
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });
                filteredItems.forEach(item => {
                    item.labels.forEach(label => {
                        if (label.includes("PredictedClass=") && !label.includes("OK")) {
                            const cls = label.split("=")[1];
                            classCounts[cls] = (classCounts[cls] || 0) + 1;
                        }
                    });
                });

                const sorted = Object.entries(classCounts).sort((a, b) => b[1] - a[1]);
                return sorted[0] || null;
            }

            getTopGroupKeys(n = 5) {
                const groupMap = {};
                const filteredItems = this.cachedFiles.filter(item => this.matchesFilters(item));

                filteredItems.forEach(item => {
                    groupMap[item.groupKey] = (groupMap[item.groupKey] || 0) + 1;
                });

                return Object.entries(groupMap)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, n)
                    .map(([groupKey, count]) => ({ groupKey, count }));
            }

            findThisDate(event) {
                const buttonElement = event.currentTarget;
                const dateValue = buttonElement.getAttribute('data-date');

                // Create a date in local time (year, monthIndex (0-based), day)
                const [year, month, day] = dateValue.split('-').map(Number);
                const localDate = new Date(year, month - 1, day);

                this.rangestart = localDate.toString();
                this.rangeend = localDate.toString();
                this.filterAndRenderFiles();
            }

            insertGroupedDates() {
                const grouped = this.groupDataByKey(); // uses the helper function below
                const container = document.querySelector('.available-dates');
                if (!container) return;

                container.innerHTML = ''; // Clear previous content
                grouped.forEach(group => {

                    const segmentDiv = document.createElement('div');

                    segmentDiv.className = 'ui segment black inverted'
                    // Create list container for this group
                    const listDiv = document.createElement('div');
                    listDiv.className = 'ui middle aligned divided list inverted';

                    segmentDiv.appendChild(listDiv);
                    group.data.forEach(dataItem => {
                        const date = dataItem.date;

                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'item';

                        // Right floated Add button
                        const rightContent = document.createElement('div');
                        rightContent.className = 'right floated content';

                        const button = document.createElement('div');
                        button.className = `ui button mini circular popUp-Btn ${dataItem.color}`;
                        button.setAttribute('data-date', date);
                        button.setAttribute('data-title', group.groupName);
                        button.setAttribute('data-content', `Fail/Pass ratio: ${(dataItem.failToPassRatio * 100).toFixed(0)}%`);

                        button.onclick = (event) => { this.findThisDate(event) };

                        // Create the icon element
                        const icon = document.createElement('i');
                        icon.className = `${dataItem.iconDetails} icon`;

                        button.appendChild(icon);
                        button.appendChild(document.createTextNode('Find'));

                        rightContent.appendChild(button);

                        // Content (date)
                        const content = document.createElement('div');
                        content.className = 'content';
                        const [year, month, day] = date.split('-').map(Number);
                        const dateFormatted = new Date(year, month - 1, day); // correct local date

                        const formatted = new Intl.DateTimeFormat('en-US', {
                            year: '2-digit',
                            month: '2-digit',
                            day: '2-digit'
                        }).format(dateFormatted);


                        content.textContent = formatted;

                        // Append parts to item
                        itemDiv.appendChild(rightContent);
                        itemDiv.appendChild(content);
                        listDiv.appendChild(itemDiv);
                    });

                    // Add group header (optional)
                    const groupHeader = document.createElement('h4');
                    groupHeader.textContent = `Group: ${group.groupName}`;
                    segmentDiv.appendChild(groupHeader);

                    // Append list to container
                    segmentDiv.appendChild(listDiv);
                    container.appendChild(segmentDiv);
                });

                $('.popUp-Btn').popup();
            }

            groupDataByKey() {
                const grouped = {};
                const filteredItems = this.cachedFiles.filter(item => this.matchesFilters(item));

                for (const item of filteredItems) {
                    const key = item.groupKey;
                    const dateOnly = item.date.split('T')[0];

                    if (!grouped[key]) {
                        grouped[key] = new Set();
                    }

                    grouped[key].add(dateOnly);
                }

                return Object.entries(grouped).map(([groupName, dateSet]) => {
                    const data = Array.from(dateSet).sort().map(date => {
                        const ratioData = this.analyzeTrends(groupName, date);
                        return {
                            date,
                            ...ratioData
                        };
                    });

                    return {
                        groupName,
                        data
                    };
                });
            }

            renderSummary() {
                const recent = this.getRecentActivity(7).length;
                const errRate = this.getErrorRate().toFixed(2);
                const commonClass = this.getMostCommonPredictedClass()?.[0] || "N/A";

                this.summaryContainer.innerHTML = `<div class="ui grid">
                    <div class="row">
                        <div class="column sixteen wide">
                    <h3 class="ui header attached top inverted">Summary</h3>
                    <div class="ui segment   attached bottom   padded ">
                        <p><strong>Recent Activity (7d):</strong> ${recent} items</p>
                        <p><strong>Error Rate:</strong> ${errRate}%</p>
                        <p><strong>Top Predicted Class:</strong> ${commonClass}</p>
                        </div> 
                        <h4 class="ui header attached bottom grey">${new Date().toLocaleString()}</h4>
                    </div>   
                    </div>   
                    <div class="row">
                        <div class="column sixteen wide" id="dateList">
                    <h3 class="ui header  top ">Available Dates</h3>
                    <div class="ui    attached bottom available-dates  ">                        
                    </div>   
                        </div>
                        </div>
  `;
            }

            async backgroundReloadCache() {
                if (!this.dirHandle) return;
                console.log('[AutoReload] Cache started at', new Date().toLocaleTimeString());

                const now = new Date();

                const newFileHandles = [];
                for await (const entry of this.dirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.endsWith('.svg')) {
                        newFileHandles.push(entry);
                    }
                }
                console.log('[AutoReload] Get Cache completed at', new Date().toLocaleTimeString());

                const newFileNames = new Set(newFileHandles.map(f => f.name));
                const existingFileNames = new Set(this.cachedFiles.map(f => f.name));

                const addedFiles = [...newFileHandles].filter(f => !existingFileNames.has(f.name));
                const removedFiles = [...this.cachedFiles].filter(f => !newFileNames.has(f.name));

                let updated = false;

                // Process new files
                for (const entry of addedFiles) {
                    const fileObj = await this.processSvgFile(entry.name, {}, now, false);
                    if (fileObj) {
                        this.cachedFiles.push(fileObj);
                        updated = true;
                    }
                }

                if (!updated) {
                    console.log('[AutoReload] Process Cache completed at', new Date().toLocaleTimeString());
                    this.showNewLabel({ live: false });
                }

                // Remove deleted files
                if (removedFiles.length) {
                    this.cachedFiles = this.cachedFiles.filter(f => newFileNames.has(f.name));
                    updated = true;
                    console.log('[AutoReload] Cache not updated at', new Date().toLocaleTimeString());
                    this.showNewLabel({ live: false });
                }

                if (updated) {
                    this.filterAndRenderFiles();
                    console.log('[AutoReload] Cache updated at', new Date().toLocaleTimeString());
                    this.showNewLabel({ live: true, count: addedFiles.length });
                }
            }

            async selectFolder() {
                try {
                    this.setCalendarDatesToDefault();
                    this.dirHandle = await window.showDirectoryPicker();
                    await this.readFolderContents();
                    this.folderName.innerHTML = `Folder:${this.dirHandle.name}` || 'Folder';


                } catch (e) {
                    console.error("Folder selection cancelled or failed:", e);
                }
            }

            startSlideshow() {
                if (this.slideshowInterval) {
                    clearInterval(this.slideshowInterval);
                    this.slideshowInterval = null;
                    document.getElementById('playSlideshowBtn').textContent = '▶️ Play Slideshow';
                    return;
                }

                this.slideshowFiles = this.cachedFiles.filter(file => {
                    return this.passesDateFilter(file.date) &&
                        (!this.filterString || file.labels.includes(this.filterString)) &&
                        (document.getElementById('showTrainedToggle')?.checked || !this.saved.includes(file.name));
                });

                if (this.slideshowFiles.length === 0) {
                    alert('No files to show in slideshow.');
                    return;
                }

                this.slideshowIndex = 0;
                document.getElementById('playSlideshowBtn').textContent = '⏸️ Stop Slideshow';

                this.slideshowInterval = setInterval(() => {
                    const file = this.slideshowFiles[this.slideshowIndex];
                    this.loadImage(file.name, file.content);

                    this.slideshowIndex = (this.slideshowIndex + 1) % this.slideshowFiles.length;
                }, 3000); // Change image every 3 seconds
            }

            setupSlideshowControls() {
                document.getElementById('playBtn').onclick = () => this.startSlideshow();
                document.getElementById('pauseBtn').onclick = () => this.stopSlideshow();
                document.getElementById('nextBtn').onclick = () => this.nextSlide();
                document.getElementById('prevBtn').onclick = () => this.prevSlide();

                document.querySelectorAll('#slideshowControls .item[data-speed]').forEach(item => {
                    item.onclick = () => {
                        this.slideshowSpeed = parseInt(item.getAttribute('data-speed'));
                        if (this.slideshowTimer) {
                            this.stopSlideshow();
                            this.startSlideshow(); // restart with new speed
                        }
                    };
                });
            }

            startSlideshow() {
                if (!this.cachedFiles.length) return;
                this.stopSlideshow();
                this.slideshowTimer = setInterval(() => this.nextSlide(), this.slideshowSpeed);
            }

            stopSlideshow() {
                if (this.slideshowTimer) {
                    clearInterval(this.slideshowTimer);
                    this.slideshowTimer = null;
                }
            }

            nextSlide() {
                if (!this.cachedFiles.length) return;
                this.slideshowIndex = (this.slideshowIndex + 1) % this.cachedFiles.length;
                const file = this.cachedFiles[this.slideshowIndex];
                this.loadImage(file.name, file.content);
            }

            prevSlide() {
                if (!this.cachedFiles.length) return;
                this.slideshowIndex = (this.slideshowIndex - 1 + this.cachedFiles.length) % this.cachedFiles.length;
                const file = this.cachedFiles[this.slideshowIndex];
                this.loadImage(file.name, file.content);
            }

            async buildCardContent(card, file) {
                const imageDiv = await this.loadImageObs(file);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'content';

                const extraContentDiv = document.createElement('div');
                extraContentDiv.className = ' extra content';

                const headerDiv = document.createElement('div');
                headerDiv.className = 'header';
                headerDiv.textContent = `PN: ${file.name.split('_')[0]} | ID: ${file.name.split('_')[2].replace('.svg', '')}`;

                const metaDiv = document.createElement('div');
                metaDiv.className = 'meta right floated';

                const svgHandle = await this.dirHandle.getFileHandle(file.name);
                const svgFile = await svgHandle.getFile();
                const date = new Date(svgFile.lastModified);

                const dateFormatted = date.toLocaleDateString();

                const timeFormatted = date.toLocaleTimeString([], {
                    hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true
                });
                metaDiv.textContent = `${dateFormatted} ${timeFormatted}`;

                const descDiv = document.createElement('div');
                descDiv.className = 'description';

                const table = document.createElement('table');
                table.className = 'ui  basic table stackable';

                const tbody = document.createElement('tbody');
                file.content.split(',').forEach(entry => {
                    const [key, value] = entry.split(':');
                    if (key && value) {
                        const row = document.createElement('tr');
                        row.innerHTML = `<td>${key.trim()}</td><td>${value.trim()}</td>`;
                        tbody.appendChild(row);
                    }
                });

                const lineByLine = document.createElement('div');
                lineByLine.className = 'description';
                const list = document.createElement('div');
                list.className = 'ui  list  '

                let iconType = null, iconText = '';

                file.content.split(',').forEach(entry => {
                    const [key, value] = entry.split(':');
                    if (key && value) {


                        const row = document.createElement('div');
                        row.className = 'item'
                        row.innerHTML = `<p>${key.trim()}:${value.trim()}</p>`;
                        list.appendChild(row);

                        if (key.includes('Fail'))
                            iconType = (key.includes('Fail') && value.includes('1')) ? 'exclamation triangle red' : 'check green';
                    }
                });

                const moreInfoBtn = document.createElement('i');
                moreInfoBtn.className = `${iconType} icon`;

                const modalBtn = document.createElement('i');
                modalBtn.className = `show-modal search plus icon`;

                lineByLine.append(list);
                descDiv.appendChild(lineByLine);

                contentDiv.appendChild(headerDiv);
                extraContentDiv.appendChild(metaDiv);
                extraContentDiv.appendChild(moreInfoBtn);
                extraContentDiv.appendChild(modalBtn);
                contentDiv.appendChild(descDiv);

                card.innerHTML = '';
                card.appendChild(imageDiv);
                card.appendChild(contentDiv);
                card.appendChild(extraContentDiv)
            }

            async runBatched(tasks, batchSize = 21) {
                let index = 0;
                while (index < tasks.length) {
                    const batch = tasks.slice(index, index + batchSize);
                    await Promise.allSettled(batch.map(task => task()));
                    index += batchSize;
                }
            }


            async renderCardGrid1() {
                const filteredFiles = this.getFilteredFiles().filter(file =>
                    this.isWithinTimeWindow(file.date)
                );

                this.filteredFiles = filteredFiles; // Cache for use in scroll
                this.renderVirtualCards(0, this.visibleCardCount + this.buffer * 2); // Initial render
            }

            renderVirtualCards1(startIndex, endIndex) {
                this.cardGridInner.innerHTML = '';

                for (let i = startIndex; i < endIndex; i++) {
                    const file = this.filteredFiles[i];
                    const index = this.cachedFiles.indexOf(file);
                    if (index === -1) continue;

                    const card = document.createElement('div');
                    card.className = 'ui small card loading';
                    card.dataset.index = index;

                    // Placeholder
                    card.innerHTML = `<div class="content"><p>Loading...</p></div>`;

                    this.cardGridInner.appendChild(card);
                }

                // Spacer divs to simulate full height
                this.cardGridSpacerTop.style.height = `${startIndex * this.cardHeight}px`;
                this.cardGridSpacerBottom.style.height = `${(this.filteredFiles.length - endIndex) * this.cardHeight}px`;

                this.observeLazyCards(); // Attach observer to only visible cards
            }

            observeLazyCards1() {
                const observer = new IntersectionObserver(async (entries) => {
                    const tasks = entries.map(entry => async () => {
                        const card = entry.target;
                        const index = parseInt(card.dataset.index);
                        const file = this.cachedFiles[index];

                        if (!file) return;

                        if (entry.isIntersecting) {
                            if (card.dataset.loaded === 'true') return;

                            card.dataset.loaded = 'true';


                            try {
                                card.onclick = () => this.loadImage(file.name, file.content);
                                await this.buildCardContent(card, file);
                                card.classList.remove('loading')
                            } catch (err) {
                                console.warn(`Failed to load content for card ${file?.name}:`, err);
                            }

                        } else {
                            if (card.dataset.loaded === 'true') {
                                this.unloadCardContent(card);
                                delete card.dataset.loaded;
                            }
                        }
                    });

                    await this.runBatched(tasks, 21); // Load/unload in batches
                }, {
                    root: this.cardGridInner,
                    rootMargin: '20px',
                    threshold: 0.1
                });

                this.cardGridInner.querySelectorAll('.ui.card').forEach(card => {
                    observer.observe(card);
                });
            }

            unloadCardContent(card) {
                card.classList.add('loading');
                card.innerHTML = `<div class="content"><p>Reloading...</p></div>`;
                card.onclick = null;
            }

            async renderCardGrid() {
                this.cardGridContainer.innerHTML = '';

                const filteredFiles = this.getFilteredFiles().filter(item => {
                    return this.isWithinTimeWindow(item.date);
                });
                if (this.search === null) {
                    this.cardGridContainer.innerHTML = `
    <div style="display: flex; justify-content: center; align-items: center; height: 100%;">
        <div class="ui warning message huge">
            <i class="exclamation triangle icon"></i>
            <div class="header">
                Selection Required
            </div>
            Please select a part number or date to view the images.
        </div>
    </div>
    `;
                    return;
                }

                filteredFiles.forEach((file, index) => {

                    const card = document.createElement('div');
                    card.className = 'ui small card loading';
                    card.dataset.index = this.cachedFiles.indexOf(file); // Keep original index

                    // Placeholder content
                    card.innerHTML = `<div class="content"><p>Loading...</p></div>`;

                    this.cardGridContainer.appendChild(card);
                });

                this.observeLazyCards();

            }

            observeLazyCards() {
                const observer = new IntersectionObserver(async (entries) => {
                    const tasks = entries.map(entry => async () => {
                        const card = entry.target;
                        const index = parseInt(card.dataset.index);
                        const file = this.cachedFiles[index];

                        if (entry.isIntersecting) {
                            // LOAD CARD
                            if (!file || card.dataset.loaded === 'true') return;

                            card.dataset.loaded = 'true';

                            try {
                                card.onclick = () => {
                                    this.loadImage(file.name, file.content);
                                };
                                await this.buildCardContent(card, file);
                                card.classList.remove('loading');
                            } catch (err) {
                                console.warn(`Failed to build content for card ${file?.name}:`, err);
                            }

                        } else {
                            // UNLOAD CARD
                            if (card.dataset.loaded === 'true') {
                                this.unloadCardContent(card);
                                delete card.dataset.loaded;
                            }
                        }
                    });

                    await this.runBatched(tasks, 9); // Process in batches
                }, {
                    root: null,
                    rootMargin: '20px',
                    threshold: 0.1
                });

                this.cardGridContainer.querySelectorAll('.ui.card').forEach(card => {
                    observer.observe(card);
                });
            }

            async generateSvgBlobFromFileName(filename) {
                try {
                    const svgHandle = await this.dirHandle.getFileHandle(filename);
                    const svgFile = await svgHandle.getFile();
                    let svgText = await svgFile.text();

                    // Optional: handle BMP embedding
                    const bmpMatch = svgText.match(/xlink:href=['"]([^'"]+\.bmp)['"]/i);
                    if (bmpMatch && bmpMatch[1]) {
                        try {
                            const bmpHandle = await this.dirHandle.getFileHandle(bmpMatch[1]);
                            const bmpFile = await bmpHandle.getFile();
                            const bmpBuffer = await bmpFile.arrayBuffer();
                            const bmpBase64 = this.arrayBufferToBase64(bmpBuffer);
                            const dataUri = `data:image/bmp;base64,${bmpBase64}`;
                            svgText = svgText.replace(bmpMatch[0], `xlink:href="${dataUri}"`);
                        } catch (err) {
                            console.warn(`⚠️ BMP not found: ${bmpMatch[1]}`, err);
                        }
                    }

                    return new Blob([svgText], { type: 'image/svg+xml' });
                } catch (e) {
                    console.error('Error generating SVG blob:', e);
                    return null;
                }
            }

            async showPreview(filename, event) {
                this.hidePreview(); // always clear previous

                this.previewHovering = true;

                // Delay slightly to avoid flicker on fast moves
                this.previewDelay = setTimeout(async () => {
                    if (!this.previewHovering) return; // if mouse already left

                    const blob = await this.generateSvgBlobFromFileName(filename);
                    if (!blob) return;

                    const preview = document.createElement('div');
                    preview.className = 'image-preview-popup';
                    preview.style.position = 'fixed';
                    preview.style.zIndex = 9999;
                    preview.style.border = '1px solid #ccc';
                    preview.style.background = '#fff';
                    preview.style.padding = '5px';
                    preview.style.boxShadow = '0 0 10px rgba(0,0,0,0.3)';
                    preview.style.maxWidth = '80vw';
                    preview.style.maxHeight = '80vh';
                    preview.style.pointerEvents = 'none';

                    const object = document.createElement('object');
                    object.type = 'image/svg+xml';
                    object.data = URL.createObjectURL(blob);
                    object.style.width = '500px';
                    object.style.height = 'auto';
                    preview.appendChild(object);

                    document.body.appendChild(preview);
                    this.previewElement = preview;

                    // Position
                    preview.style.left = `${event.clientX + 15}px`;
                    preview.style.top = `${event.clientY + 15}px`;

                    // Hide after 30 sec
                    this.previewTimeout = setTimeout(() => {
                        this.hidePreview();
                    }, 30000);
                }, 200); // slight delay
            }

            hidePreview() {
                if (this.previewTimeout) {
                    clearTimeout(this.previewTimeout);
                    this.previewTimeout = null;
                }
                if (this.previewElement) {
                    this.previewElement.remove();
                    this.previewElement = null;
                }
            }

            imageGridSettings() {
                if (this.cardGridToggleBool.checked) {
                    this.gridControl.grid.map(i => this.cardGridContainer.classList.remove(i))
                    this.gridControl.list.map(i => this.cardGridContainer.classList.add(i));
                } else {
                    this.gridControl.list.map(i => this.cardGridContainer.classList.remove(i))
                    this.gridControl.grid.map(i => this.cardGridContainer.classList.add(i));
                }
            }


            matchesFilters(item) {
                const searchTerm = this.search?.toLowerCase();

                // Text search
                const matchesSearch = !this.search || (
                    item.name.toLowerCase().includes(searchTerm) ||
                    item.labels.some(label => label.toLowerCase().includes(searchTerm))
                );

                // Date filter
                const matchesDate = this.passesDateFilter(item.date);

                // Label filter
                const matchesLabel = !this.filterString || item.labels.includes(this.filterString);

                return matchesSearch && matchesDate && matchesLabel;
            }

            matchesFiltersNoLabel(item) {
                const searchTerm = this.search?.toLowerCase();

                // Text search
                const matchesSearch = !this.search || (
                    item.name.toLowerCase().includes(searchTerm) ||
                    item.labels.some(label => label.toLowerCase().includes(searchTerm))
                );

                // Date filter
                const matchesDate = this.passesDateFilter(item.date);

                // Label filter
                const matchesLabel = !this.filterString || item.labels.includes(this.filterString);

                return matchesSearch && matchesDate;
            }

            matchesTimelineFilter(item) {
                const searchTerm = this.search?.toLowerCase();

                // Text search
                const matchesSearch = !this.search || (
                    item.file.toLowerCase().includes(searchTerm) ||
                    item.labels.some(label => label.toLowerCase().includes(searchTerm))
                );

                // Label filter
                const matchesLabel = !this.filterString || item.labels.includes(this.filterString);

                return matchesSearch && matchesLabel;
            }

            makeStats(stat) {
                return `
                <div class=" column five wide">
                <div class="ui ${stat.color} inverted segment center aligned  ">
                   
                            <div class="ui inverted statistic  ">
                                <div class="value"  data-value="${stat.value}">
                                    ${stat.value}
                                </div>
                                <div class="label">
                                    ${stat.label}
                                    <br/>
                                    <small>( ${((stat?.value / stat?.total) * 100) <= 50 ? `<i class="arrow down icon"></i>` : `<i class="arrow up icon"></i>`}${((stat?.value / stat?.total) * 100).toFixed(0)}% )</small>
                                </div>
                            </div>
                        
                </div>
                </div>
                `
            }

            searchThisValue(value) {

                alert(value)
            }

            renderStatsAMain() {
                let totalPass = 0;
                let totalFail = 0;
                const predictedClassCounts = {};

                // Filtered items using reusable filter method
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });

                filteredItems.forEach(item => {
                    item.labels.forEach(label => {
                        if (label.startsWith("Job.Pass=")) {
                            totalPass += parseInt(label.split("=")[1]);
                        } else if (label.startsWith("Job.Fail=")) {
                            totalFail += parseInt(label.split("=")[1]);
                        } else if (label.includes("PredictedClass=")) {
                            const predClass = label.split("=")[1];
                            predictedClassCounts[predClass] = (predictedClassCounts[predClass] || 0) + 1;
                        }
                    });
                });

                const totalItems = totalPass + totalFail;

                const statHeaderData = `
                <div class="ui grid">
                   <div class="row">
                    ${this.makeStats({ total: totalItems, value: totalItems, label: "Total Items", color: 'teal' })}
                    ${this.makeStats({ total: totalItems, value: totalPass, label: "Total Passes", color: 'green' })}
                    ${this.makeStats({ total: totalItems, value: totalFail, label: "Total Fails", color: 'red' })}
                        </div>  
                    </div>`

                const statsHtml = `
                <div>
  

        <div class="">
    

    <div class="ui three column  grid">
    ${Object.entries(predictedClassCounts).map(([key, val]) => `
      <div class="column">
        <div class="ui segment fluid center aligned inverted red">
            <div class="ui  statistic inverted">
                <div class="value">${val}
                    </div>
                <div class="label">Predicted: ${key}
                    </div>
            </div>
         </div>
      </div>
    `).join("")}
  </div>
    </div>
  </div>
  `;

                this.statsHtmlMain.innerHTML = statsHtml;
                this.statsHtmlMainHeaderStats.innerHTML = statHeaderData;
            }

            checkAlerts(thresholdPercent = 5) {
                const errorRates = this.getErrorRateTrend();
                return Object.entries(errorRates)
                    .filter(([day, rate]) => rate > thresholdPercent)
                    .map(([day, rate]) => ({ day, rate }));
            }

            getPredictedClassDistribution() {
                const classCounts = {};
                // Filter items first
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });

                filteredItems.forEach(item => {
                    item.labels.forEach(label => {
                        if (label.includes("PredictedClass=")) {
                            const predClass = label.split("=")[1];
                            classCounts[predClass] = (classCounts[predClass] || 0) + 1;
                        }
                    });
                });

                return classCounts;
            }

            getPassFailByGroup() {
                const groupStats = {};
                // Filter items first
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });

                filteredItems.forEach(item => {
                    const group = item.groupKey;
                    if (!groupStats[group]) groupStats[group] = { pass: 0, fail: 0 };

                    item.labels.forEach(label => {
                        if (label.startsWith("Job.Pass=")) groupStats[group].pass += parseInt(label.split("=")[1]);
                        if (label.startsWith("Job.Fail=")) groupStats[group].fail += parseInt(label.split("=")[1]);
                    });
                });

                return groupStats;
            }

            getErrorRateTrend() {
                // returns an object: { '2025-06-04': 5, '2025-06-05': 2, ... }
                const trend = {};
                // Filter items first
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });

                filteredItems.forEach(item => {
                    const day = new Date(item.date).toISOString().split('T')[0];
                    if (!trend[day]) trend[day] = { pass: 0, fail: 0 };

                    item.labels.forEach(label => {
                        if (label.startsWith("Job.Pass=")) trend[day].pass += parseInt(label.split("=")[1]);
                        if (label.startsWith("Job.Fail=")) trend[day].fail += parseInt(label.split("=")[1]);
                    });
                });

                // Calculate error rate percentage per day
                const errorRateTrend = {};
                for (const day in trend) {
                    const { pass, fail } = trend[day];
                    const total = pass + fail;
                    errorRateTrend[day] = total > 0 ? (fail / total) * 100 : 0;
                }
                return errorRateTrend;
            }

            computeStatsData() {
                let totalPass = 0;
                let totalFail = 0;
                const predictedClassCounts = {};

                // Filter items
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });

                filteredItems.forEach(item => {
                    item.labels.forEach(label => {
                        if (label.startsWith("Job.Pass=")) {
                            totalPass += parseInt(label.split("=")[1]);
                        } else if (label.startsWith("Job.Fail=")) {
                            totalFail += parseInt(label.split("=")[1]);
                        } else if (label.includes("PredictedClass=")) {
                            const predClass = label.split("=")[1];
                            predictedClassCounts[predClass] = (predictedClassCounts[predClass] || 0) + 1;
                        }
                    });
                });

                const totalItems = totalPass + totalFail;

                // Additional insights
                const errorRateTrend = this.getErrorRateTrend();
                const alerts = this.checkAlerts(5);
                const passFailByGroup = this.getPassFailByGroup();

                return {
                    totalItems,
                    totalPass,
                    totalFail,
                    predictedClassCounts,
                    errorRateTrend,
                    alerts,
                    passFailByGroup
                };
            }

            renderStats() {
                let totalPass = 0;
                let totalFail = 0;
                const predictedClassCounts = {};

                // Filter items first
                const filteredItems = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) });

                filteredItems.forEach(item => {

                    item.labels.forEach(label => {
                        if (label.startsWith("Job.Pass=")) {
                            totalPass += parseInt(label.split("=")[1]);
                        } else if (label.startsWith("Job.Fail=")) {
                            totalFail += parseInt(label.split("=")[1]);
                        } else if (label.includes("PredictedClass=")) {
                            const predClass = label.split("=")[1];
                            predictedClassCounts[predClass] = (predictedClassCounts[predClass] || 0) + 1;
                        }
                    });
                });

                const totalItems = totalPass + totalFail;

                // Get more insights
                const errorRateTrend = this.getErrorRateTrend();
                const alerts = this.checkAlerts(5); // Alert if error rate > 5%
                const passFailByGroup = this.getPassFailByGroup();

                // Format the error rate trend as a simple list or stats
                const errorRateHtml = Object.entries(errorRateTrend).map(([day, rate]) => `
    <div class="column">
        <div class="ui segment center aligned red inverted">
                <div class="ui  statistic inverted">
      <div class="value">${rate.toFixed(0)}%</div>
      <div class="label">Errors on ${day}</div>
    </div>
    </div>
    </div>
  `).join("");

                // Format alerts (if any)
                const alertsHtml = alerts.length > 0 ? `
    <div class="ui red message">
      <strong>Alerts:</strong> High error rates detected on days:
      ${alerts.map(a => a.day).join(", ")}
    </div>
  ` : "";

                // Format pass/fail by groupKey summary (top 3)
                const groupsHtml = Object.entries(passFailByGroup)
                    .slice(0, 5)
                    .map(([group, counts]) => {
                        const totalGroup = counts.pass + counts.fail;
                        const failRate = totalGroup === 0 ? 0 : (counts.fail / totalGroup) * 100;
                        return `
                        <div class="column">
        <div class="ui segment center aligned inverted green">
      <div class="ui  statistic inverted">
        <div class="value">${failRate.toFixed(0)}%</div>
        <div class="label"> Part #:${group}</div>
      </div>
      </div>
      </div>`;
                    }).join("");

                // Predicted classes summary (top 3)
                const predictedHtml = Object.entries(predictedClassCounts)
                    .slice(0, 5)
                    .map(([cls, count]) => `
                    <div class="column">
        <div class="ui segment center aligned yellow inverted">
      <div class="ui  statistic inverted">
        <div class="value">${count}</div>
        <div class="label">Predicted: ${cls}</div>
      </div>
      </div>
      </div>
    `).join("");

                // Compose full HTML summary
                const statsHtml = `<div class="ui grid">
                    <div class="row">
                    ${this.makeStatSegment({ color: 'yellow', size: 'four', value: predictedHtml, label: "Top 5 Predicted Classes" })}
                    ${this.makeStatSegment({ color: 'red', size: 'four', value: errorRateHtml, label: "Error Rate Trend" })}
                    ${this.makeStatSegment({ color: 'green', size: 'four', value: groupsHtml, label: "Top 5 Fail Rate by Group", alert: alertsHtml })}
                    </div>
                    </div>`;

                this.statsHtml.innerHTML = statsHtml;
            }

            makeStatSegment(item) {
                return `
                <div class="column ${item.size} wide">
                    <h3 class="ui header attached top ">${item.label}</h3>
                     <div class=" ui segment inverted ${item.color} attached bottom  ">
                        <div class="ui one column grid">${item.value}</div>
                        <div class="ui one column grid">${item.alert ? item.alert : ''}</div>
                        </div>
                    </div>`
            }

            sortFilesByDate(files, recentFirst = true) {
                return files.sort((a, b) => {
                    const dateA = new Date(a.date);
                    const dateB = new Date(b.date);
                    return recentFirst ? dateB - dateA : dateA - dateB;
                });
            }

            imagePreviewDropdown() {
                const groupedFiles = {};
                this.summaryData = {};
                this.availableFilters.clear();

                for (const file of this.cachedFiles) {

                    // If there is a search query, filter the files based on it
                    if (this.search && !file.name.toLowerCase().includes(this.search.toLowerCase()) &&
                        !file.labels.some(label => label.toLowerCase().includes(this.search.toLowerCase()))) {
                        continue;  // Skip files that don't match the search
                    }

                    // Date filter check
                    if (!this.passesDateFilter(file.date)) continue;

                    // Other filters
                    if (this.filterString && !file.labels.includes(this.filterString)) continue;

                    // Trained toggle filter
                    if (!document.getElementById('showTrainedToggle')?.checked && this.saved.includes(file.name)) continue;

                    // Group the files by groupKey
                    if (!groupedFiles[file.groupKey]) groupedFiles[file.groupKey] = [];
                    groupedFiles[file.groupKey].push(file);

                    // Track labels for summary and available filters
                    for (const label of file.labels) {
                        this.summaryData[label] = (this.summaryData[label] || 0) + 1;
                        this.availableFilters.add(label);
                    }
                }

                // Sort files within each group by date (recent to oldest) if sorting is enabled
                if (this.sortByRecent) {
                    for (const key in groupedFiles) {
                        groupedFiles[key] = this.sortFilesByDate(groupedFiles[key], true);
                    }
                }
                return groupedFiles;
            }

            async filterAndRenderFiles() {
                this.showLoader();
                // Render the filtered files and charts
                const groupedFiles = this.imagePreviewDropdown()
                this.renderGroupedFiles(groupedFiles);
                this.renderSummaryChart();
                this.renderFilterDropdown();
                this.renderTimelineChart();
                this.renderHeartbeatChart();
                this.renderCumulativeCountChart();
                this.renderStats();
                this.renderStatsAMain();
                this.renderSummary();
                this.getHealthIndicator();
                await this.renderCardGrid();
                this.setupCalendarDates();
                this.renderTrendVisualizer();
                this.insertGroupedDates();
                this.search = null;
                this.searchNumDropdown();
                this.hideLoader();

            }

            renderTrendVisualizer() {
                const filtered = this.cachedFiles.filter(item => { return this.matchesFilters(item) && this.isWithinTimeWindow(item.date) })
                this.trendVisualizer = new TrendVisualizer('trend-container', filtered);
                this.trendVisualizerCards = new TrendVisualizerCards('trend-container-card', filtered, this.animatedCounter, this.updateSearch);
            }

            toggleView() {
                if (this.viewToggle.checked) {
                    this.chartView.style.display = 'block';
                    this.imageView.style.display = 'none';
                } else {
                    this.chartView.style.display = 'none';
                    this.imageView.style.display = 'flex';
                }
            }

            toggleAutoReload() {

                if (!this.autoReloadInterval) {
                    this.autoReloadInterval = setInterval(() => {
                        if (this.dirHandle) {
                            this.backgroundReloadCache();
                        }
                    }, 30000);
                } else {
                    clearInterval(this.autoReloadInterval);
                    this.autoReloadInterval = null;
                    console.log("Auto-reload stopped.");
                }
            }

            setupDateDropdown() {
                $('#dateFilterDropdown').dropdown({
                    onChange: (value) => {
                        this.dateFilter = value;
                        this.filterAndRenderFiles();
                    }
                });
            }

            setupCalendarDates() {

                /*  $('#rangestart').calendar({
                     type: 'date',
                      eventDates: this.dates.map(str => ({
                         date: new Date(str.date),
                         class: 'red',
                         message: str.message
                     })),
     
                     enabledDates:this.dates.map(str => ({
                         date: new Date(str.date)}))
                 }); */



            }

            showNewLabel(data) {
                const id = "newLabel"
                if (data.live) {
                    document.getElementById(id)?.remove();
                    const label = document.createElement('div');
                    label.id = id
                    label.innerHTML = `<a class="ui teal circular label right floating top ">${data.count}</a>`;
                    document.getElementById('iconLabelDash').append(label);
                } else {
                    document.getElementById(id).remove();
                }
            }

            setupCalendar() {

                $('#rangestart').calendar({
                    type: 'date',
                    endCalendar: $('#rangeend'),

                    onChange: (date) => {
                        const bool = (date && this.dirHandle !== null);
                        if (bool) this.rangestart = new Date(date.setHours(0, 0, 0, 0));
                    },


                });
                $('#rangeend').calendar({
                    type: 'date',
                    startCalendar: $('#rangestart'),
                    onChange: (date) => {
                        const bool = (date && this.dirHandle !== null);
                        if (bool) this.rangeend = new Date(date.setHours(0, 0, 0, 0));
                        this.filterAndRenderFiles();
                        this.searchNumDropdown();
                    }
                });

            }

            showLoader() {
                document.getElementById('globalLoader')?.style.setProperty('display', 'block');
            }

            hideLoader() {
                document.getElementById('globalLoader')?.style.setProperty('display', 'none');
            }

            processBatchO = async (batch, groupedFiles, now, showTrained) => {
                const results = await Promise.all(
                    batch.map(entry => this.processSvgFile(entry.name, groupedFiles, now, showTrained))
                );
                this.cachedFiles.push(...results.filter(Boolean));
            };





            parseTxtContentInWorker(txtContent, svgName, showTrained, savedList, filterString) {
                return new Promise((resolve, reject) => {
                    const workerCode = `
      onmessage = function(e) {
        const { txtContent, svgName, showTrained, saved, filterString } = e.data;

        try {
          const kvPairs = txtContent.split(',').map(e => {
            const [k, v] = e.split(':').map(x => x.trim());
            return { key: k, value: v };
          });

          if (filterString && !kvPairs.some(({ key, value }) => \`\${key}=\${value}\` === filterString)) {
            postMessage(null); return;
          }

          if (!showTrained && saved.includes(svgName)) {
            postMessage(null); return;
          }

          const keySet = new Set();
          for (const { key } of kvPairs) {
            if (keySet.has(key)) {
              postMessage(null); return;
            }
            keySet.add(key);
          }

          const parts = svgName.split('_');
          const groupKey = parts[0];
          const sortVal = parseInt(parts[2].replace('.svg', ''));

          const labels = kvPairs.map(({ key, value }) => \`\${key}=\${value}\`);

          postMessage({
            groupKey,
            sortVal,
            labels
          });
        } catch (err) {
          postMessage(null);
        }
      };
    `;

                    const blob = new Blob([workerCode], { type: "application/javascript" });
                    const worker = new Worker(URL.createObjectURL(blob));

                    worker.postMessage({
                        txtContent,
                        svgName,
                        showTrained,
                        saved: savedList,
                        filterString
                    });

                    worker.onmessage = (e) => {
                        worker.terminate();
                        resolve(e.data); // either parsed data or null
                    };

                    worker.onerror = (err) => {
                        worker.terminate();
                        reject(err);
                    };
                });
            }

            async processSvgFile2(svgName, groupedFiles, now, showTrained) {
                const txtName = svgName.replace('.svg', '.txt');

                try {
                    const [svgHandle, txtHandle] = await Promise.all([
                        this.dirHandle.getFileHandle(svgName),
                        this.dirHandle.getFileHandle(txtName)
                    ]);

                    const [svgFile, txtFile] = await Promise.all([
                        svgHandle.getFile(),
                        txtHandle.getFile()
                    ]);

                    const fileDate = new Date(svgFile.lastModified);
                    if (!this.passesDateFilter(fileDate)) return;

                    const txtContent = await txtFile.text();

                    // 🔁 Offload parsing + filtering to worker
                    const parsed = await this.parseTxtContentInWorker(
                        txtContent,
                        svgName,
                        showTrained,
                        this.saved,
                        this.filterString
                    );

                    if (!parsed) return;

                    // 🔁 Add to main thread state
                    const { groupKey, sortVal, labels } = parsed;

                    if (!groupedFiles[groupKey]) groupedFiles[groupKey] = [];
                    groupedFiles[groupKey].push({
                        name: svgName,
                        sortValue: sortVal,
                        content: txtContent
                    });

                    if (!this.groupKey.includes(groupKey)) this.groupKey.push(groupKey);

                    for (const label of labels) {
                        this.summaryData[label] = (this.summaryData[label] || 0) + 1;
                        this.availableFilters.add(label);
                    }

                    this.timeSeriesData.push({
                        timestamp: fileDate.toISOString(),
                        file: svgName,
                        label: svgName.replace('.svg', ''),
                        labels
                    });

                    this.dates.push({
                        date: fileDate.toLocaleDateString(),
                        message: `Captured PN: ${svgName.split('_')[0]}`,
                    });

                    return {
                        name: svgName,
                        groupKey,
                        sortValue: sortVal,
                        content: txtContent,
                        date: fileDate.toISOString(),
                        labels
                    };

                } catch (e) {
                    console.warn(`Skipping ${svgName}: ${e.message}`);
                    return null;
                }
            }




            //////////////////////////////////// DB Functions ////////////////////////////////////////////////



            openDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('svg-file-db', 1);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('files')) {
                            const store = db.createObjectStore('files', { keyPath: 'name' });
                            store.createIndex('date', 'date');
                            store.createIndex('groupKey', 'groupKey');
                        }
                    };
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            async saveFileToDB(fileMeta) {
                const db = await this.openDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readwrite');
                    const store = tx.objectStore('files');
                    const request = store.put(fileMeta);

                    request.onsuccess = () => resolve(true);
                    request.onerror = (e) => reject(e.target.error);
                });
            }

            async isFileInDB(name) {
                const db = await this.openDB();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readonly');
                    const store = tx.objectStore('files');
                    const request = store.get(name);

                    request.onsuccess = (event) => {
                        resolve(event.target.result);  // will be `undefined` if not found
                    };
                    request.onerror = (event) => {
                        reject(event.target.error);
                    };
                });
            }


            async clearDB() {
                const db = await this.openDB();
                const tx = db.transaction('files', 'readwrite');
                await tx.objectStore('files').clear();
                await tx.complete;
            }



            async readFolderContents() {

                this.showLoader();
                this.timeSeriesData = [];
                if (!this.dirHandle) return;

                this.imageList.innerHTML = '';
                this.summaryData = {};
                this.availableFilters.clear();
                this.cachedFiles = [];

                const groupedFiles = {};
                const now = new Date();
                const showTrained = document.getElementById('showTrainedToggle')?.checked;

                const fileHandles = [];

                // Scan all .svg files and filter by cache
                for await (const entry of this.dirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.endsWith('.svg')) {
                        const cached = await this.isFileInDB(entry.name);

                        if (!cached) {
                            fileHandles.push(entry); // Queue for processing
                        } else {
                            // Preload cached result directly into groupedFiles
                            const group = groupedFiles[cached.groupKey] ||= [];
                            group.push(cached);
                        }
                    }
                }

                const concurrency = 300;
                const initialRenderCount = 6000;

                const firstBatch = fileHandles.slice(0, initialRenderCount);
                for (let i = 0; i < firstBatch.length; i += concurrency) {
                    const batch = firstBatch.slice(i, i + concurrency);

                    await this.processBatch(batch, groupedFiles, now, showTrained);

                    const progress = Math.min(100, Math.round((i + concurrency) / fileHandles.length * 100));
                    $('#progressBar').progress({
                        percent: progress,
                        total: `${progress}%`
                    });
                }

                this.renderGroupedFiles(groupedFiles);
                this.filterAndRenderFiles();
                this.setupCalendarDates();

                const remainingHandles = fileHandles.slice(initialRenderCount);

                const backgroundProcess = async (startIdx) => {
                    if (startIdx >= remainingHandles.length) {
                        this.filterAndRenderFiles();
                        return;
                    }

                    const batch = remainingHandles.slice(startIdx, startIdx + concurrency);
                    await this.processBatch(batch, groupedFiles, now, showTrained);

                    const progress = Math.min(100, Math.round((initialRenderCount + startIdx + concurrency) / fileHandles.length * 100));
                    $('#toast-progress').progress('set percent', progress);

                    setTimeout(() => backgroundProcess(startIdx + concurrency), 10);
                };

                setTimeout(() => backgroundProcess(0), 0);
            }


            processBatch = async (batch, groupedFiles, now, showTrained) => {
                const results = await Promise.all(
                    batch.map(async entry => {

                        const result = await this.processSvgFile(entry.name, groupedFiles, now, showTrained);
                        if (result) {
                            // Add to groupedFiles if not already grouped
                            const group = groupedFiles[result.groupKey] ||= [];
                            group.push(result);
                            // Cache in IndexedDB
                            await this.saveFileToDB(result);

                            return result;
                        }
                        return null;
                    })
                );

                this.cachedFiles.push(...results.filter(Boolean));
            };


            /////////////////////////////////////////////////////////////////////////////////////////////////

            async readFolderContentsO() {
                this.showLoader();
                this.timeSeriesData = [];
                if (!this.dirHandle) return;

                this.imageList.innerHTML = '';
                this.summaryData = {};
                this.availableFilters.clear();
                this.cachedFiles = [];

                const groupedFiles = {};
                const now = new Date();
                const showTrained = document.getElementById('showTrainedToggle')?.checked;
                const fileHandles = [];


                for await (const entry of this.dirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.endsWith('.svg')) {
                        fileHandles.push(entry);
                    }
                }

                const concurrency = 300;
                const initialRenderCount = 6000;

                const firstBatch = fileHandles.slice(0, initialRenderCount);
                for (let i = 0; i < firstBatch.length; i += concurrency) {
                    const batch = firstBatch.slice(i, i + concurrency);
                    await this.processBatch(batch, groupedFiles, now, showTrained);

                    const progress = Math.min(100, Math.round((i + concurrency) / fileHandles.length * 100));

                    $('#progressBar').progress({
                        percent: progress,
                        total: `${progress}%`
                    });

                }

                this.renderGroupedFiles(groupedFiles);
                this.filterAndRenderFiles();
                this.setupCalendarDates();

                const remainingHandles = fileHandles.slice(initialRenderCount);

                //$('#toast-container').toast({ position: 'bottom right', displayTime: 0})

                const backgroundProcess = async (startIdx) => {
                    if (startIdx >= remainingHandles.length) {
                        this.filterAndRenderFiles();
                        return;
                    };

                    const batch = remainingHandles.slice(startIdx, startIdx + concurrency);
                    await this.processBatch(batch, groupedFiles, now, showTrained);

                    const progress = Math.min(100, Math.round((initialRenderCount + startIdx + concurrency) / fileHandles.length * 100));

                    $('#toast-progress').progress('set percent', progress);

                    // Use setTimeout to yield control back to the browser
                    setTimeout(() => backgroundProcess(startIdx + concurrency), 10);
                };

                // Kick off background task
                setTimeout(() => backgroundProcess(0), 0);
            }

            async processSvgFile(svgName, groupedFiles, now, showTrained) {
                const txtName = svgName.replace('.svg', '.txt');

                try {
                    const [svgHandle, txtHandle] = await Promise.all([
                        this.dirHandle.getFileHandle(svgName),
                        this.dirHandle.getFileHandle(txtName)
                    ]);

                    const [svgFile, txtFile] = await Promise.all([
                        svgHandle.getFile(),
                        txtHandle.getFile()
                    ]);

                    const fileDate = new Date(svgFile.lastModified);
                    if (!this.passesDateFilter(fileDate)) return;


                    this.dates.push({
                        date: fileDate.toLocaleDateString(),
                        message: `Captured PN: ${svgName.split('_')[0]}`,
                    });

                    const txtContent = await txtFile.text();
                    const kvPairs = txtContent.split(',').map(e => {
                        const [k, v] = e.split(':').map(x => x.trim());
                        return { key: k, value: v };
                    });

                    // Apply filter only once on parsed data
                    if (this.filterString && !kvPairs.some(({ key, value }) => `${key}=${value}` === this.filterString)) {
                        return;
                    }

                    if (!showTrained && this.saved.includes(svgName)) return;

                    // Avoid duplicate keys
                    const keySet = new Set();
                    for (const { key } of kvPairs) {
                        if (keySet.has(key)) return;
                        keySet.add(key);
                    }

                    // Add to grouped files
                    const parts = svgName.split('_');
                    const groupKey = parts[0];
                    const sortVal = parseInt(parts[2].replace('.svg', ''));

                    if (!groupedFiles[groupKey]) groupedFiles[groupKey] = [];
                    groupedFiles[groupKey].push({ name: svgName, sortValue: sortVal, content: txtContent });
                    this.groupKey.some(item => item === groupKey) ? null : this.groupKey.push(groupKey);

                    // Update summary data and filters
                    for (const { key, value } of kvPairs) {
                        if (!key || !value) continue;
                        const label = `${key}=${value}`;
                        this.summaryData[label] = (this.summaryData[label] || 0) + 1;
                        this.availableFilters.add(label);
                    }

                    // Track for timeline chart
                    this.timeSeriesData.push({
                        timestamp: fileDate.toISOString(),
                        file: svgName,
                        label: svgName.replace('.svg', ''),
                        labels: kvPairs.map(({ key, value }) => `${key}=${value}`)
                    });

                    return {
                        name: svgName,
                        groupKey,
                        sortValue: sortVal,
                        content: txtContent,
                        date: fileDate.toISOString(),
                        labels: kvPairs.map(({ key, value }) => `${key}=${value}`)
                    };

                } catch (e) {
                    // Optionally log or handle the error
                    // console.warn(`Skipping ${svgName}: ${e.message}`);
                    return null;
                }
            }

            passesDateFilter(fileDate) {
                //const now = new Date();
                let result = true;

                const fileDateObj = new Date(fileDate);
                const startDateObj = new Date(this.rangestart);
                const endDateObj = new Date(this.rangeend);

                // Normalize times to 00:00:00 to compare dates only
                fileDateObj.setHours(0, 0, 0, 0);
                startDateObj.setHours(0, 0, 0, 0);
                endDateObj.setHours(0, 0, 0, 0);

                return (fileDateObj >= startDateObj && fileDateObj <= endDateObj);

            }

            renderGroupedFiles(grouped) {
                const fragment = document.createDocumentFragment();
                for (const groupKey in grouped) {
                    const files = grouped[groupKey].sort((a, b) => a.sortValue - b.sortValue);
                    const titleDiv = document.createElement('div');
                    titleDiv.className = 'title';
                    titleDiv.innerHTML = `<i class="dropdown icon"></i>${groupKey} (${files.length})`;

                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'content';

                    const scrollWrap = document.createElement('div');
                    scrollWrap.style.display = 'flex';
                    scrollWrap.style.flexWrap = 'nowrap';
                    scrollWrap.style.overflowX = 'auto';
                    scrollWrap.style.gap = '10px';

                    files.forEach(file => {
                        const btnWrapper = document.createElement('div');
                        const label = (file.content || '').split(',');
                        const labelText = label[0]?.split(':')[1]?.trim() + '/' + (label[1]?.split(':')[1]?.trim() || '');

                        const btn = document.createElement('div');
                        btn.className = 'ui basic label';
                        btn.style.cursor = 'pointer';
                        btn.textContent = file.name;

                        const detail = document.createElement('div');
                        detail.className = 'detail';
                        detail.textContent = labelText || 'N/A';
                        btn.appendChild(detail);

                        btn.onclick = () => this.loadImage(file.name, file.content);// Task use for modal

                        if (this.saved.includes(file.name)) {
                            btn.classList.add('red');
                            btn.title = 'Already trained';
                        }

                        btnWrapper.appendChild(btn);
                        scrollWrap.appendChild(btnWrapper);
                    });

                    contentDiv.appendChild(scrollWrap);
                    fragment.appendChild(titleDiv);
                    fragment.appendChild(contentDiv);
                }

                this.imageList.innerHTML = '';
                this.imageList.appendChild(fragment);
                $('.ui.accordion').accordion();
            }

            async loadImage(svgFilename, txtContent) {
                this.currentFilename = svgFilename;
                const dataTable = document.getElementById('dataTable');
                dataTable.innerHTML = '';

                const svgHandle = await this.dirHandle.getFileHandle(svgFilename);
                const svgFile = await svgHandle.getFile();
                const lastModified = new Date(svgFile.lastModified);

                const dateFormatted = lastModified.toLocaleDateString([], {
                    year: 'numeric', month: 'short', day: 'numeric'
                });
                const timeFormatted = lastModified.toLocaleTimeString([], {
                    hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true
                });

                document.querySelector('#imageView h4.ui.header').innerHTML =
                    `Preview : ${svgFilename.split('_')[0]} <div class="sub header">Captured ${dateFormatted} at ${timeFormatted}</div>`;

                txtContent.split(',').forEach(entry => {
                    const [key, value] = entry.split(':');
                    if (key && value) {
                        const row = document.createElement('tr');
                        row.innerHTML = `<td>${key.trim()}</td><td>${value.trim()}</td>`;
                        dataTable.appendChild(row);
                    }
                });

                const isSaved = this.saved.includes(svgFilename);
                this.saveBtn.textContent = isSaved ? 'Untrain' : 'Train';
                this.saveBtn.classList.toggle('red', isSaved);
                this.saveBtn.classList.toggle('green', !isSaved);

                const svgText = await svgFile.text();
                let finalSvg = svgText;


                const bmpMatch = finalSvg.match(/xlink:href=['"]([^'"]+\.bmp)['"]/i);
                if (bmpMatch && bmpMatch[1]) {
                    try {
                        const bmpHandle = await this.dirHandle.getFileHandle(bmpMatch[1]);
                        const bmpFile = await bmpHandle.getFile();
                        const bmpBuffer = await bmpFile.arrayBuffer();
                        const bmpBase64 = this.arrayBufferToBase64(bmpBuffer);
                        const dataUri = `data:image/bmp;base64,${bmpBase64}`;
                        finalSvg = finalSvg.replace(bmpMatch[0], `xlink:href="${dataUri}"`);
                    } catch (err) {
                        console.warn(`⚠️ BMP not found: ${bmpMatch[1]}`, err);
                    }
                }


                const blob = new Blob([finalSvg], { type: 'image/svg+xml' });
                const svgUrl = URL.createObjectURL(blob);
                this.svgViewer.setAttribute('data', svgUrl);

                setTimeout(() => {
                    this.svgViewer.style.display = 'none';
                    this.svgViewer.offsetHeight;
                    this.svgViewer.style.display = 'block';
                }, 70);
            }

            async loadImageObs(file) {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'image';
                imageDiv.style = `
        height: 200px;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #f9f9f9;
    `;

                let finalSvg = '';
                try {
                    const svgHandle = await this.dirHandle.getFileHandle(file.name);
                    const svgFile = await svgHandle.getFile();
                    const svgText = await svgFile.text();
                    finalSvg = svgText;

                    // Embed BMP inside SVG if needed
                    const bmpMatch = finalSvg.match(/xlink:href=['"]([^'"]+\.bmp)['"]/i);
                    if (bmpMatch && bmpMatch[1]) {
                        try {
                            const bmpHandle = await this.dirHandle.getFileHandle(bmpMatch[1]);
                            const bmpFile = await bmpHandle.getFile();
                            const bmpBuffer = await bmpFile.arrayBuffer();
                            const bmpBase64 = this.arrayBufferToBase64(bmpBuffer);
                            const dataUri = `data:image/bmp;base64,${bmpBase64}`;
                            finalSvg = finalSvg.replace(bmpMatch[0], `xlink:href="${dataUri}"`);
                        } catch (err) {
                            console.warn(`⚠️ BMP not found: ${bmpMatch[1]}`, err);
                        }
                    }

                    const blob = new Blob([finalSvg], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(blob);

                    // image Card trigger imageDiv.innerHTML = `<object type="image/svg+xml" data="${url}" style="width: 100%; height: 100%;"></object>`;
                    imageDiv.innerHTML = `<img class="ui large image" src="${url}" alt="SVG image" style="width: 100%; height: 100%; object-fit: cover;">`;

                } catch {
                    // Fallback if SVG fails
                    imageDiv.innerHTML = `
            <div class="ui icon message"><i class="file icon"></i>No image</div>
        `;
                }

                return imageDiv;
            }

            arrayBufferToBase64(buffer) {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                const len = bytes.length;
                for (let i = 0; i < len; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            getFilteredFiles() {
                let data = this.cachedFiles.filter(file => {
                    if (!this.passesDateFilter(file.date)) return false;
                    if (this.filterString && !file.labels.includes(this.filterString)) return false;
                    // If there is a search query, filter the files based on it
                    if (this.search && !file.name.toLowerCase().includes(this.search.toLowerCase()) &&
                        !file.labels.some(label => label.toLowerCase().includes(this.search.toLowerCase()))) {
                        return false;  // Skip files that don't match the search
                    }
                    return true;
                });
                if (this.sortByRecent) {
                    return this.sortFilesByDate(data, true);
                } else {
                    return this.sortFilesByDate(data, false);;
                }
            }

            toggleSave() {
                if (!this.currentFilename) return alert('No file selected');
                const index = this.saved.indexOf(this.currentFilename);

                if (this.saveBtn.textContent === 'Train') {
                    if (index === -1) {
                        this.saved.push(this.currentFilename);
                        localStorage.setItem('savedFilenames', JSON.stringify(this.saved));
                        alert(`Saved: ${this.currentFilename}`);
                    }
                } else {
                    if (index !== -1) {
                        this.saved.splice(index, 1);
                        localStorage.setItem('savedFilenames', JSON.stringify(this.saved));
                        alert(`Untrained: ${this.currentFilename}`);
                    }
                }

                this.filterAndRenderFiles();
            }

            isWithinTimeWindow(fileDateIn) {
                const fileDate = new Date(fileDateIn);

                if (this.startTime) {
                    const start1 = new Date(this.startTime.start1);
                    const start2 = new Date(this.startTime.start2);
                    const startMax = new Date(Math.max(start1, start2));
                    if (fileDate <= startMax) return false;
                }

                if (this.endTime) {
                    const end1 = new Date(this.endTime.end1);
                    const end2 = new Date(this.endTime.end2);
                    const endMin = new Date(Math.min(end1, end2));
                    if (fileDate >= endMin) return false;
                }

                return true;
            }

            dateRangeFilter(fileDate) {
                const fileDateObj = new Date(fileDate);
                const startDateObj = new Date(this.rangestart);
                const endDateObj = new Date(this.rangeend);

                // Normalize times to 00:00:00 to compare dates only
                fileDateObj.setHours(0, 0, 0, 0);
                startDateObj.setHours(0, 0, 0, 0);
                endDateObj.setHours(0, 0, 0, 0);
                return (fileDateObj >= startDateObj && fileDateObj <= endDateObj);
            }

            renderTimelineChart() {
                const ctx = this.timelineChartCtx;

                if (this.timelineChartInstance) {
                    this.timelineChartInstance.destroy();
                }

                const filteredData = this.timeSeriesData.filter(entry => {
                    const fileDate = new Date(entry.timestamp); // Ensure it's a Date
                    if (!this.dateRangeFilter(fileDate)) return false;

                    if (!this.isWithinTimeWindow(fileDate)) return false;

                    if (!this.matchesTimelineFilter(entry)) return false;

                    return true;
                });

                const grouped = {};

                filteredData.forEach((entry) => {
                    const labelGroup = this.filterString || 'All';

                    if (!grouped[labelGroup]) grouped[labelGroup] = [];
                    grouped[labelGroup].push({
                        x: new Date(entry.timestamp).toISOString(), // time on X-axis
                        y: 1, // constant Y to align all events horizontally
                        label: entry.file
                    });
                });

                const datasets = Object.keys(grouped).map((group, i) => ({
                    label: group,
                    data: grouped[group],
                    pointBackgroundColor: `hsl(${(i * 60) % 360}, 70%, 50%)`,
                    pointRadius: 5
                }));

                this.timelineChartInstance = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets },
                    options: {
                        responsive: true,
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    tooltipFormat: 'PPpp'
                                },
                                title: { display: true, text: 'Timestamp' }
                            },
                            y: {
                                display: false // no need for Y-axis ticks if events are aligned
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        const point = context.raw;
                                        const date = new Date(point.x);
                                        const time = date.toLocaleTimeString();
                                        const day = date.toLocaleDateString();
                                        return `${point.label} - ${day} ${time}`;
                                    }
                                }
                            },
                            title: {
                                display: false,
                                text: 'Filtered Timeline (Time on X-axis)'
                            }
                        }
                    }
                });
            }

            renderSummaryChart() {
                const ctx = this.summaryChartCtx;
                const isStacked = this.stackToggle?.checked;

                const fieldValueCounts = {};

                Object.keys(this.summaryData).forEach(label => {
                    const [field, value] = label.split('=');
                    if (!field || !value) return;

                    if (!fieldValueCounts[field]) {
                        fieldValueCounts[field] = {};
                    }

                    fieldValueCounts[field][value] = (fieldValueCounts[field][value] || 0) + this.summaryData[label];
                });

                const allFields = Object.keys(fieldValueCounts);
                const allValues = Array.from(
                    new Set(
                        Object.values(fieldValueCounts)
                            .flatMap(obj => Object.keys(obj))
                    )
                ).sort();

                const datasets = allValues.map((val, index) => ({
                    label: val,
                    data: allFields.map(field => fieldValueCounts[field][val] || 0),
                    backgroundColor: `hsl(${(index * 60) % 360}, 70%, 60%)`
                }));

                if (this.chartInstance) {
                    this.chartInstance.destroy();
                }

                this.chartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: allFields,
                        datasets
                    },
                    options: {
                        plugins: {
                            title: {
                                display: false
                            }
                        },
                        responsive: true,
                        scales: {
                            x: {
                                stacked: isStacked, // ✅ stack on X axis
                                title: {
                                    display: true,
                                    text: 'Field'
                                }
                            },
                            y: {
                                stacked: isStacked, // ✅ stack on Y axis
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Count'
                                }
                            }
                        }
                    }
                });
            }

            renderCumulativeCountChart() {
                const ctx = this.cumulativeCountChartCtx;

                if (this.cumulativeCountChartInstance) {
                    this.cumulativeCountChartInstance.destroy();
                }

                const filteredData = this.timeSeriesData.filter(entry => {
                    const fileDate = new Date(entry.timestamp);
                    if (!this.dateRangeFilter(fileDate)) return false;
                    if (!this.isWithinTimeWindow(fileDate)) return false;
                    if (!this.matchesTimelineFilter(entry)) return false;

                    return true;
                });

                // Step 1: Group by prefix and sort entries by time
                const grouped = {};
                filteredData.forEach(entry => {
                    const prefix = entry.file.split('_')[0];
                    if (!grouped[prefix]) grouped[prefix] = [];

                    grouped[prefix].push({
                        timestamp: new Date(entry.timestamp).getTime(),
                        label: entry.file
                    });
                });

                // Step 2: Sort each group and compute cumulative counts
                const datasets = [];
                Object.keys(grouped).forEach((prefix, index) => {
                    const entries = grouped[prefix].sort((a, b) => a.timestamp - b.timestamp);
                    const cumulativeData = [];

                    let count = 0;
                    entries.forEach(entry => {
                        count += 1;
                        cumulativeData.push({
                            x: new Date(entry.timestamp).toISOString(),
                            y: count
                        });
                    });

                    datasets.push({
                        label: prefix,
                        data: cumulativeData,
                        borderColor: `hsl(${(index * 60) % 360}, 70%, 40%)`,
                        backgroundColor: `hsla(${(index * 60) % 360}, 70%, 40%, 0.2)`,
                        fill: false,
                        tension: 0.2,
                        pointRadius: 0,
                        showLine: true
                    });
                });

                // Step 3: Render the chart
                this.cumulativeCountChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        animation: {
                            x: {
                                type: 'number',
                                easing: 'linear',
                                duration: 200,
                                from: NaN, // the point is initially skipped
                                delay(ctx) {
                                    if (ctx.type !== 'data' || ctx.xStarted) {
                                        return 0;
                                    }
                                    ctx.xStarted = true;
                                    return ctx.index * 70; // delay per point
                                }
                            },
                            y: {
                                type: 'number',
                                easing: 'linear',
                                duration: 200,
                                from: NaN,
                                delay(ctx) {
                                    if (ctx.type !== 'data' || ctx.yStarted) {
                                        return 0;
                                    }
                                    ctx.yStarted = true;
                                    return ctx.index * 70;
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    tooltipFormat: 'PPpp'
                                },
                                title: {
                                    display: true,
                                    text: 'Time'
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Cumulative Count'
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: context => {
                                        const point = context.raw;
                                        return `${context.dataset.label}: ${point.y} total as of ${new Date(point.x).toLocaleTimeString()}`;
                                    }
                                }
                            },
                            title: {
                                display: false,
                                text: 'Cumulative Count Over Time by Prefix'
                            },
                            legend: {
                                display: true
                            }
                        }
                    }
                });
            }

            renderHeartbeatChart() {
                const ctx = this.heartbeatChartCtx;

                if (this.heartbeatChartInstance) {
                    this.heartbeatChartInstance.destroy();
                }

                const filteredData = this.timeSeriesData.filter(entry => {
                    const fileDate = new Date(entry.timestamp);
                    if (!this.dateRangeFilter(fileDate)) return false;
                    if (!this.isWithinTimeWindow(fileDate)) return false;
                    if (!this.matchesTimelineFilter(entry)) return false;

                    return true;
                });

                // Step 1: Time bin and count pass/fail per prefix
                const timeBinSize = 60 * 1000; // 1 minute
                const groupedCounts = {}; // { prefix: { binnedTime: { pass: count, fail: count } } }

                filteredData.forEach(entry => {
                    const prefix = entry.file.split('_')[0];
                    const timestamp = new Date(entry.timestamp).getTime();
                    const binnedTime = new Date(Math.floor(timestamp / timeBinSize) * timeBinSize).toISOString();
                    const isPass = entry.labels.includes("Job.Pass=1");

                    if (!groupedCounts[prefix]) groupedCounts[prefix] = {};
                    if (!groupedCounts[prefix][binnedTime]) {
                        groupedCounts[prefix][binnedTime] = { pass: 0, fail: 0 };
                    }

                    if (isPass) {
                        groupedCounts[prefix][binnedTime].pass += 1;
                    } else {
                        groupedCounts[prefix][binnedTime].fail += 1;
                    }
                });

                // Step 2: Build datasets (1 for pass, 1 for fail per prefix)
                const datasets = [];
                const colors = ['green', 'red'];

                Object.keys(groupedCounts).forEach((prefix, index) => {
                    const timePoints = groupedCounts[prefix];

                    const passData = [];
                    const failData = [];

                    Object.keys(timePoints).forEach(time => {
                        passData.push({ x: time, y: timePoints[time].pass });
                        failData.push({ x: time, y: timePoints[time].fail });
                    });

                    passData.sort((a, b) => new Date(a.x) - new Date(b.x));
                    failData.sort((a, b) => new Date(a.x) - new Date(b.x));

                    datasets.push({
                        label: `${prefix} - Pass`,
                        data: passData,
                        borderColor: 'green',
                        backgroundColor: 'rgba(0, 128, 0, 0.4)',
                        fill: false,
                        tension: 0.1,
                        stack: prefix, // allow stacking pass/fail per prefix
                        pointRadius: 0.5,
                        showLine: true
                    });

                    datasets.push({
                        label: `${prefix} - Fail`,
                        data: failData,
                        borderColor: 'red',
                        backgroundColor: 'rgba(255, 0, 0, 0.4)',
                        fill: false,
                        tension: 0.1,
                        stack: prefix, // allow stacking pass/fail per prefix
                        pointRadius: 0.5,
                        showLine: true
                    });
                });

                // Step 3: Chart.js config
                this.heartbeatChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        animation: {
                            x: {
                                type: 'number',
                                easing: 'linear',
                                duration: 200,
                                from: NaN, // the point is initially skipped
                                delay(ctx) {
                                    if (ctx.type !== 'data' || ctx.xStarted) {
                                        return 0;
                                    }
                                    ctx.xStarted = true;
                                    return ctx.index * 70; // delay per point
                                }
                            },
                            y: {
                                type: 'number',
                                easing: 'linear',
                                duration: 200,
                                from: NaN,
                                delay(ctx) {
                                    if (ctx.type !== 'data' || ctx.yStarted) {
                                        return 0;
                                    }
                                    ctx.yStarted = true;
                                    return ctx.index * 70;
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    tooltipFormat: 'PPpp'
                                },
                                title: {
                                    display: true,
                                    text: 'Time'
                                }
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Job Count'
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: context => {
                                        const point = context.raw;
                                        return `${context.dataset.label}: ${point.y} at ${new Date(point.x).toLocaleTimeString()}`;
                                    }
                                }
                            },
                            title: {
                                display: false,
                                text: 'Job Count Over Time (Pass vs Fail, by Prefix)'
                            },
                            legend: {
                                display: true
                            }
                        }
                    }
                });
            }

            renderFilterDropdown() {
                const dropdown = $('#filterDropdown');
                const menu = dropdown.find('.menu');
                menu.empty();

                menu.append(`<div class="item" data-value="">All (${Object.values(this.summaryData).reduce((a, b) => a + b, 0)})</div>`);
                [...this.availableFilters].sort().forEach(filter => {
                    const count = this.summaryData[filter] || 0;
                    menu.append(`<div class="item" data-value="${filter}">${filter.split('=')[1]} (${count})</div>`);
                });

                dropdown.dropdown('refresh');
                dropdown.dropdown({
                    onChange: (value) => {
                        this.filterString = value;
                        this.filterAndRenderFiles();
                    }
                });
            }

            clearDate() {
                this.setCalendarDatesToDefault();
                $('#specificDateCalendar').calendar('clear');
                this.filterAndRenderFiles();
            }
        }

        const folderManager = new FolderManager();
        $('.menu.item.sidebar').tab();

        const driver = window.driver.js.driver;

        const tour = driver({
            showProgress: true,
            overlayColor: 'rgba(0,0,0,0.6)',        // dim overlay for focus
            overlayOpacity: 1,                    // partial transparency
            animate: true,                          // enable animated transitions
            nextBtnText: 'Next →',
            prevBtnText: '← Back',
            doneBtnText: 'Finish',
            steps: [
                {
                    element: '.ui.top.fixed.menu .item h3',
                    popover: {
                        title: 'App Title',
                        description: 'This shows your branding and app name.',
                        side: 'bottom',
                        align: 'start'
                    }
                },
                {
                    element: '#folderPicker',
                    popover: {
                        title: 'Folder Picker',
                        description: 'Use this button to select a folder.',
                        side: 'bottom',
                        align: 'start'
                    }
                },
                {
                    element: '#reloadBtn',
                    popover: {
                        title: ' Reload Folder',
                        description: 'Use this button to reload the current folder.',
                        side: 'bottom',
                        align: 'start'
                    }
                },
                {
                    element: '#searchQry',
                    popover: {
                        title: 'Search Box',
                        description: 'Type keywords to search through your data.',
                        side: 'bottom',
                        align: 'start'
                    }
                },
                {
                    element: '#rangestart',
                    popover: {
                        title: 'Start Date Filter',
                        description: 'Select the start of your date range.',
                        side: 'top',
                        align: 'start'
                    }
                },
                {
                    element: '#rangeend',
                    popover: {
                        title: 'End Date Filter',
                        description: 'Select the end of your date range.',
                        side: 'top',
                        align: 'start'
                    }
                },
                {
                    element: '.ui.left.sidebar .item[data-tab="dashboard-page"]',
                    popover: {
                        title: 'Sidebar Navigation',
                        description: 'Navigate between different pages here.',
                        side: 'right',
                        align: 'start'
                    }
                },
                {
                    element: '#timelineChart',
                    popover: {
                        title: 'Timeline Chart',
                        description: 'Visualize your data over time.',
                        side: 'top',
                        align: 'center'
                    }
                },
                {
                    popover: {
                        title: 'All Set!',
                        description: "That's a quick tour of your app. Explore further!",
                        side: 'center',
                        align: 'center'
                    }
                }
            ]
        });

        document.getElementById('startTourBtn').addEventListener('click', () => {
            tour.drive();
        });
    </script>

</body>

</html>